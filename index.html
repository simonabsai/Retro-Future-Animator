<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RETRO-FUTURE GRAPHIC ANIMATOR</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        .status {
            text-align: center;
            padding: 12px 16px;
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            margin: 16px 0;
            font-size: 0.875rem;
            color: #888888;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Inter', system-ui, sans-serif;
            background: #000000;
            color: #ffffff;
            min-height: 100vh;
            font-weight: 400;
            letter-spacing: -0.01em;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 32px;
            border-bottom: 1px solid #1a1a1a;
            padding-bottom: 24px;
        }
        
        .header h1 {
            font-size: 1.75rem;
            font-weight: 500;
            color: #ffffff;
            margin-bottom: 4px;
            letter-spacing: -0.02em;
        }
        
        .header .subtitle {
            font-size: 0.75rem;
            color: #888888;
            font-weight: 400;
            letter-spacing: 0.1em;
        }
        
        .control-panel {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
        }
        
        .control-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-row-2 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .control-group label {
            font-weight: 500;
            color: #ffffff;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .control-group input,
        .control-group select {
            padding: 8px 12px;
            border: 1px solid #333333;
            border-radius: 4px;
            font-size: 0.875rem;
            background: #000000;
            color: #ffffff;
            transition: border-color 0.15s ease;
        }
        
        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #00ffff;
        }
        
        .text-input-full {
            grid-column: 1 / -1;
        }
        
        .text-input-full input {
            width: 100%;
            padding: 12px 16px;
        }
        
        .action-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .btn {
            padding: 8px 16px;
            border: 1px solid #333333;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            background: #000000;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .btn:hover {
            border-color: #00ffff;
            color: #00ffff;
        }
        
        .btn-primary {
            background: #00ffff;
            color: #000000;
            border-color: #00ffff;
        }
        
        .btn-primary:hover {
            background: #ffffff;
            border-color: #ffffff;
        }
        
        .canvas-container {
            display: flex;
            justify-content: center;
            margin: 32px 0;
        }
        
        canvas {
            border: 1px solid #333333;
            border-radius: 4px;
            background: #000000;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .footer {
            text-align: center;
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid #1a1a1a;
            color: #888888;
            font-size: 0.75rem;
        }
        
        .footer .absai-logo {
            display: inline-block;
            margin: 8px 0;
        }
        
        .footer .absai-logo img {
            height: 60px;
            width: auto;
            max-width: 200px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>RETRO-FUTURE GRAPHIC ANIMATOR</h1>
            <div class="subtitle">Built by ABSAI</div>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group">
                    <label>Pattern</label>
                    <select id="pattern">
                        <option value="text" selected>Text Display</option>
                        <option value="heart">Heart</option>
                        <option value="dots">Random Dots</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Custom Text</label>
                    <input type="text" id="customText" placeholder="Enter your text..." value="IONIQ 6 N">
                </div>
                
                <div class="control-group">
                    <label>Color Scheme</label>
                    <select id="baseColor">
                        <option value="red" selected>N Red</option>
                        <option value="blue">Perf Blue</option>
                        <option value="white">White/Gray</option>
                        <option value="green">Matrix Green</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Duration</label>
                    <select id="duration">
                        <option value="3" selected>3s</option>
                        <option value="5">5s</option>
                        <option value="10">10s</option>
                    </select>
                </div>
            </div>
            
            <div class="control-row-2">
                <div class="control-group">
                    <label>Animation</label>
                    <select id="animation">
                        <option value="none">Static</option>
                        <option value="pulse">Pulse</option>
                        <option value="blink">Blink</option>
                        <option value="glitch">Glitch</option>
                        <option value="laser">Laser Scan</option>
                        <option value="collision">Sphere Collision</option>
                        <option value="matrix">Matrix Rain</option>
                        <option value="equalizer">Graphic Equalizer</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Matrix Rain Color</label>
                    <select id="matrixColor">
                        <option value="green" selected>Classic Green</option>
                        <option value="blue">Perf. Blue</option>
                        <option value="red">N Red</option>
                        <option value="white">Pure White</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <!-- Empty for spacing -->
                </div>
                
                <div class="control-group">
                    <!-- Empty for spacing -->
                </div>
            </div>
            
            <div class="action-buttons">
                <button class="btn btn-primary" onclick="generatePattern()">Generate</button>
                <button class="btn" onclick="animateDisplay()" id="animateBtn">Animate</button>
                <button class="btn" onclick="pauseAnimation()" id="pauseBtn" style="display: none;">Pause</button>
                <button class="btn" onclick="saveAsImage()">Save PNG</button>
            </div>
        </div>
        
        <div class="status" id="status">Ready to create pixel art!</div>
        
        <div class="canvas-container">
            <canvas id="canvas" width="800" height="400"></canvas>
        </div>
        
        <div class="footer">
            <div>Built using AI vibe coding by Simon Woollard - June 07 2025</div>
            <div class="absai-logo">
                <img src="absai-logo.png" alt="ABSAI Logo" /> 
            </div>
        </div>
    </div>

    <script>
        // Global variables
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let pixelGrid = [];
        let isAnimating = false;
        let animationFrame = null;
        
        // Constants
        const PIXEL_SIZE = 4;
        const PIXEL_GAP = 1;
        
        // Color themes
        const colorThemes = {
            red: {
                levels: ['#000000', '#1a0000', '#330000', '#4d0000', '#660000', '#800000', '#990000', '#b30000', '#cc0000', '#dc3312', '#e64d33', '#f06666', '#ff8080']
            },
            blue: {
                levels: ['#000000', '#0a0f14', '#141e28', '#1e2d3c', '#283c50', '#324b64', '#3c5a78', '#46698c', '#5078a0', '#6487b4', '#7896c8', '#8ca5dc', '#aacae6']
            },
            white: {
                levels: ['#000000', '#111111', '#222222', '#333333', '#444444', '#555555', '#666666', '#777777', '#888888', '#999999', '#aaaaaa', '#cccccc', '#ffffff']
            },
            green: {
                levels: ['#000000', '#0a1a0a', '#143314', '#1e4d1e', '#286628', '#328032', '#3c993c', '#46b346', '#50cc50', '#64dc64', '#78e678', '#8cf08c', '#a6ffa6']
            }
        };
        
        // 3x5 pixel font (smaller for matrix rain)
        const smallPixelFont = {
            'A': [[0,1,0],[1,0,1],[1,1,1],[1,0,1],[1,0,1]],
            'B': [[1,1,0],[1,0,1],[1,1,0],[1,0,1],[1,1,0]],
            'C': [[0,1,1],[1,0,0],[1,0,0],[1,0,0],[0,1,1]],
            'D': [[1,1,0],[1,0,1],[1,0,1],[1,0,1],[1,1,0]],
            'E': [[1,1,1],[1,0,0],[1,1,0],[1,0,0],[1,1,1]],
            'F': [[1,1,1],[1,0,0],[1,1,0],[1,0,0],[1,0,0]],
            'G': [[0,1,1],[1,0,0],[1,0,1],[1,0,1],[0,1,1]],
            'H': [[1,0,1],[1,0,1],[1,1,1],[1,0,1],[1,0,1]],
            'I': [[1,1,1],[0,1,0],[0,1,0],[0,1,0],[1,1,1]],
            'J': [[0,0,1],[0,0,1],[0,0,1],[1,0,1],[0,1,0]],
            'K': [[1,0,1],[1,1,0],[1,0,0],[1,1,0],[1,0,1]],
            'L': [[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,1,1]],
            'M': [[1,0,1],[1,1,1],[1,0,1],[1,0,1],[1,0,1]],
            'N': [[1,0,1],[1,1,1],[1,0,1],[1,0,1],[1,0,1]],
            'O': [[0,1,0],[1,0,1],[1,0,1],[1,0,1],[0,1,0]],
            'P': [[1,1,0],[1,0,1],[1,1,0],[1,0,0],[1,0,0]],
            'Q': [[0,1,0],[1,0,1],[1,1,1],[0,1,1],[0,0,1]],
            'R': [[1,1,0],[1,0,1],[1,1,0],[1,0,1],[1,0,1]],
            'S': [[0,1,1],[1,0,0],[0,1,0],[0,0,1],[1,1,0]],
            'T': [[1,1,1],[0,1,0],[0,1,0],[0,1,0],[0,1,0]],
            'U': [[1,0,1],[1,0,1],[1,0,1],[1,0,1],[0,1,0]],
            'V': [[1,0,1],[1,0,1],[1,0,1],[1,0,1],[0,1,0]],
            'W': [[1,0,1],[1,0,1],[1,0,1],[1,1,1],[1,0,1]],
            'X': [[1,0,1],[0,1,0],[0,1,0],[0,1,0],[1,0,1]],
            'Y': [[1,0,1],[1,0,1],[0,1,0],[0,1,0],[0,1,0]],
            'Z': [[1,1,1],[0,0,1],[0,1,0],[1,0,0],[1,1,1]],
            '0': [[0,1,0],[1,0,1],[1,0,1],[1,0,1],[0,1,0]],
            '1': [[0,1,0],[1,1,0],[0,1,0],[0,1,0],[1,1,1]],
            '2': [[0,1,0],[1,0,1],[0,1,0],[1,0,0],[1,1,1]],
            '3': [[1,1,0],[0,0,1],[0,1,0],[0,0,1],[1,1,0]],
            '4': [[1,0,1],[1,0,1],[1,1,1],[0,0,1],[0,0,1]],
            '5': [[1,1,1],[1,0,0],[1,1,0],[0,0,1],[1,1,0]],
            '6': [[0,1,1],[1,0,0],[1,1,0],[1,0,1],[0,1,0]],
            '7': [[1,1,1],[0,0,1],[0,1,0],[0,1,0],[0,1,0]],
            '8': [[0,1,0],[1,0,1],[0,1,0],[1,0,1],[0,1,0]],
            '9': [[0,1,0],[1,0,1],[0,1,1],[0,0,1],[1,1,0]],
            ' ': [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]],
            '?': [[0,1,0],[1,0,1],[0,1,0],[0,0,0],[0,1,0]],
            '!': [[0,1,0],[0,1,0],[0,1,0],[0,0,0],[0,1,0]],
            '.': [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,1,0]],
            ':': [[0,0,0],[0,1,0],[0,0,0],[0,1,0],[0,0,0]],
            '-': [[0,0,0],[0,0,0],[1,1,1],[0,0,0],[0,0,0]]
        };
        
        // 5x7 pixel font (original size)
        const pixelFont = {
            'A': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
            'B': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0]],
            'C': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,1],[0,1,1,1,0]],
            'D': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0]],
            'E': [[1,1,1,1,1],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
            'F': [[1,1,1,1,1],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]],
            'G': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'H': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
            'I': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1]],
            'J': [[0,0,1,1,1],[0,0,0,1,0],[0,0,0,1,0],[0,0,0,1,0],[0,0,0,1,0],[1,0,0,1,0],[0,1,1,0,0]],
            'K': [[1,0,0,0,1],[1,0,0,1,0],[1,0,1,0,0],[1,1,0,0,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]],
            'L': [[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
            'M': [[1,0,0,0,1],[1,1,0,1,1],[1,0,1,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
            'N': [[1,0,0,0,1],[1,1,0,0,1],[1,0,1,0,1],[1,0,0,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
            'O': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'P': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]],
            'Q': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,1,0],[0,1,1,0,1]],
            'R': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]],
            'S': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[0,1,1,1,0],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'T': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
            'U': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'V': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0]],
            'W': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,1,0,1],[1,1,0,1,1],[1,0,0,0,1]],
            'X': [[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1],[1,0,0,0,1]],
            'Y': [[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
            'Z': [[1,1,1,1,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
            '0': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,1,1],[1,0,1,0,1],[1,1,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            '1': [[0,0,1,0,0],[0,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1]],
            '2': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,1,1,1,1]],
            '3': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,1,1,0],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            '4': [[0,0,0,1,0],[0,0,1,1,0],[0,1,0,1,0],[1,0,0,1,0],[1,1,1,1,1],[0,0,0,1,0],[0,0,0,1,0]],
            '5': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,0],[0,0,0,0,1],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            '6': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            '7': [[1,1,1,1,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[0,1,0,0,0],[0,1,0,0,0]],
            '8': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            '9': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,1],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            ' ': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],
            '?': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,1,0,0]],
            '!': [[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,1,0,0]],
            '.': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,1,1,0,0],[0,1,1,0,0]],
            ':': [[0,0,0,0,0],[0,1,1,0,0],[0,1,1,0,0],[0,0,0,0,0],[0,1,1,0,0],[0,1,1,0,0],[0,0,0,0,0]],
            '-': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]
        };
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        function initDisplay() {
            const gridWidth = Math.floor(canvas.width / (PIXEL_SIZE + PIXEL_GAP));
            const gridHeight = Math.floor(canvas.height / (PIXEL_SIZE + PIXEL_GAP));
            
            pixelGrid = [];
            for (let y = 0; y < gridHeight; y++) {
                pixelGrid[y] = [];
                for (let x = 0; x < gridWidth; x++) {
                    pixelGrid[y][x] = 0;
                }
            }
            
            return { gridWidth, gridHeight };
        }
        
        function drawPixelGrid() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const baseColor = document.getElementById('baseColor').value;
            const palette = colorThemes[baseColor] || colorThemes.red;
            
            for (let y = 0; y < pixelGrid.length; y++) {
                for (let x = 0; x < pixelGrid[y].length; x++) {
                    const pixel = pixelGrid[y][x];
                    
                    if (pixel && pixel !== 0) {
                        let color;
                        
                        // Check if this pixel has special color information
                        if (pixel.isSpecialColor) {
                            // Use the specific color stored in the pixel
                            color = pixel.color;
                        } else {
                            // Use normal color scheme for regular pixels
                            const intensity = Math.floor(pixel * (palette.levels.length - 1));
                            color = palette.levels[Math.min(intensity, palette.levels.length - 1)];
                        }
                        
                        ctx.fillStyle = color;
                        const pixelX = x * (PIXEL_SIZE + PIXEL_GAP);
                        const pixelY = y * (PIXEL_SIZE + PIXEL_GAP);
                        ctx.fillRect(pixelX, pixelY, PIXEL_SIZE, PIXEL_SIZE);
                    }
                }
            }
        }
        
        function generateTextPattern(text) {
            const { gridWidth, gridHeight } = initDisplay();
            
            // Handle long text - split at 15 characters
            if (text.length > 15) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                
                for (let word of words) {
                    const testLine = currentLine ? currentLine + ' ' + word : word;
                    if (testLine.length > 15) {
                        if (currentLine) {
                            lines.push(currentLine);
                            currentLine = word;
                        } else {
                            lines.push(word.substring(0, 15));
                            currentLine = word.substring(15);
                        }
                    } else {
                        currentLine = testLine;
                    }
                }
                if (currentLine) lines.push(currentLine);
                
                // Draw multi-line text
                const charWidth = 5;
                const charHeight = 7;
                const charSpacing = 2;
                const lineSpacing = 3;
                
                const totalHeight = lines.length * charHeight + (lines.length - 1) * lineSpacing;
                const startY = Math.max(0, Math.floor((gridHeight - totalHeight) / 2));
                
                for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                    const line = lines[lineIndex];
                    const lineWidth = line.length * (charWidth + charSpacing) - charSpacing;
                    const lineStartX = Math.max(0, Math.floor((gridWidth - lineWidth) / 2));
                    const lineY = startY + lineIndex * (charHeight + lineSpacing);
                    
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i].toUpperCase();
                        const charData = pixelFont[char];
                        
                        if (charData) {
                            const charX = lineStartX + i * (charWidth + charSpacing);
                            
                            for (let y = 0; y < charHeight; y++) {
                                for (let x = 0; x < charWidth; x++) {
                                    const pixelX = charX + x;
                                    const pixelY = lineY + y;
                                    
                                    if (pixelX < gridWidth && pixelY < gridHeight && pixelX >= 0 && pixelY >= 0) {
                                        pixelGrid[pixelY][pixelX] = charData[y][x];
                                    }
                                }
                            }
                        }
                    }
                }
                return;
            }
            
            // Single line text
            const charWidth = 5;
            const charHeight = 7;
            const charSpacing = 2;
            
            const totalWidth = text.length * (charWidth + charSpacing) - charSpacing;
            const startX = Math.max(0, Math.floor((gridWidth - totalWidth) / 2));
            const startY = Math.max(0, Math.floor((gridHeight - charHeight) / 2));
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i].toUpperCase();
                const charData = pixelFont[char];
                
                if (charData) {
                    const charX = startX + i * (charWidth + charSpacing);
                    
                    for (let y = 0; y < charHeight; y++) {
                        for (let x = 0; x < charWidth; x++) {
                            const pixelX = charX + x;
                            const pixelY = startY + y;
                            
                            if (pixelX < gridWidth && pixelY < gridHeight && pixelX >= 0 && pixelY >= 0) {
                                pixelGrid[pixelY][pixelX] = charData[y][x];
                            }
                        }
                    }
                }
            }
        }
        
        function generateHeartPattern() {
            const { gridWidth, gridHeight } = initDisplay();
            const centerX = gridWidth / 2;
            const centerY = gridHeight / 2;
            
            const heart = [
                [0,1,1,0,0,0,1,1,0],
                [1,1,1,1,0,1,1,1,1],
                [1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1],
                [0,1,1,1,1,1,1,1,0],
                [0,0,1,1,1,1,1,0,0],
                [0,0,0,1,1,1,0,0,0],
                [0,0,0,0,1,0,0,0,0]
            ];
            
            const startX = Math.floor(centerX - heart[0].length / 2);
            const startY = Math.floor(centerY - heart.length / 2);
            
            for (let y = 0; y < heart.length; y++) {
                for (let x = 0; x < heart[y].length; x++) {
                    const pixelX = startX + x;
                    const pixelY = startY + y;
                    if (pixelX >= 0 && pixelX < gridWidth && pixelY >= 0 && pixelY < gridHeight) {
                        pixelGrid[pixelY][pixelX] = heart[y][x];
                    }
                }
            }
        }
        
        function generateDotsPattern() {
            const { gridWidth, gridHeight } = initDisplay();
            
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (Math.random() > 0.8) {
                        pixelGrid[y][x] = Math.random();
                    } else {
                        pixelGrid[y][x] = 0;
                    }
                }
            }
        }
        
        function generatePattern() {
            const pattern = document.getElementById('pattern').value;
            const text = document.getElementById('customText').value || 'IONIQ 6 N';
            
            switch(pattern) {
                case 'text':
                    generateTextPattern(text);
                    break;
                case 'heart':
                    generateHeartPattern();
                    break;
                case 'dots':
                    generateDotsPattern();
                    break;
                default:
                    generateTextPattern(text);
            }
            
            drawPixelGrid();
            updateStatus(`Generated ${pattern} pattern!`);
        }
        
        function animateDisplay() {
            const animation = document.getElementById('animation').value;
            const duration = parseInt(document.getElementById('duration').value) * 1000;
            
            if (animation === 'none') {
                updateStatus('No animation selected');
                return;
            }
            
            if (isAnimating) {
                cancelAnimationFrame(animationFrame);
                isAnimating = false;
                // Clean up matrix columns when stopping animation
                if (window.matrixColumns) {
                    delete window.matrixColumns;
                }
                // Clean up equalizer bars when stopping animation
                if (window.equalizerBars) {
                    delete window.equalizerBars;
                }
            }
            
            isAnimating = true;
            
            // Update button visibility
            document.getElementById('animateBtn').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'inline-block';
            
            const startTime = Date.now();
            const originalGrid = pixelGrid.map(row => [...row]);
            
            updateStatus(`Animating: ${animation} for ${duration/1000}s`);
            
            function animate() {
                if (!isAnimating || Date.now() - startTime > duration) {
                    isAnimating = false;
                    // Clean up matrix columns when animation ends
                    if (window.matrixColumns) {
                        delete window.matrixColumns;
                    }
                    // Clean up equalizer bars when animation ends
                    if (window.equalizerBars) {
                        delete window.equalizerBars;
                    }
                    
                    // Update button visibility
                    document.getElementById('animateBtn').style.display = 'inline-block';
                    document.getElementById('pauseBtn').style.display = 'none';
                    
                    pixelGrid = originalGrid;
                    drawPixelGrid();
                    updateStatus('Animation complete');
                    return;
                }
                
                const elapsed = Date.now() - startTime;
                
                switch(animation) {
                    case 'pulse':
                        const pulseValue = (Math.sin(elapsed / 200) + 1) / 2;
                        for (let y = 0; y < pixelGrid.length; y++) {
                            for (let x = 0; x < pixelGrid[y].length; x++) {
                                if (originalGrid[y][x] > 0) {
                                    pixelGrid[y][x] = originalGrid[y][x] * (0.3 + pulseValue * 0.7);
                                }
                            }
                        }
                        break;
                        
                    case 'collision':
                        // Epic sphere collision animation
                        const { gridWidth, gridHeight } = { gridWidth: pixelGrid[0].length, gridHeight: pixelGrid.length };
                        const centerX = gridWidth / 2;
                        const centerY = gridHeight / 2;
                        const sphereRadius = Math.min(gridWidth, gridHeight) * 0.15; // Smaller spheres for collision
                        
                        // Animation phases with precise timing
                        const totalDuration = duration;
                        const approachTime = totalDuration * 0.4;    // 40% - spheres approach
                        const eclipseTime = totalDuration * 0.1;     // 10% - eclipse moment
                        const explosionTime = totalDuration * 0.2;   // 20% - explosion
                        const fusionTime = totalDuration * 0.3;      // 30% - fusion and aftermath
                        
                        let phase = 'approach';
                        let phaseProgress = 0;
                        
                        if (elapsed < approachTime) {
                            phase = 'approach';
                            phaseProgress = elapsed / approachTime;
                        } else if (elapsed < approachTime + eclipseTime) {
                            phase = 'eclipse';
                            phaseProgress = (elapsed - approachTime) / eclipseTime;
                        } else if (elapsed < approachTime + eclipseTime + explosionTime) {
                            phase = 'explosion';
                            phaseProgress = (elapsed - approachTime - eclipseTime) / explosionTime;
                        } else {
                            phase = 'fusion';
                            phaseProgress = (elapsed - approachTime - eclipseTime - explosionTime) / fusionTime;
                        }
                        
                        // Clear canvas - reset all pixels
                        for (let y = 0; y < gridHeight; y++) {
                            for (let x = 0; x < gridWidth; x++) {
                                pixelGrid[y][x] = 0;
                            }
                        }
                        
                        if (phase === 'approach') {
                            // Two spheres moving toward each other
                            const startDistance = gridWidth * 0.4;
                            const currentDistance = startDistance * (1 - phaseProgress);
                            
                            const leftSphereX = centerX - currentDistance;
                            const rightSphereX = centerX + currentDistance;
                            
                            // Draw red sphere (left)
                            drawGradientSphere(leftSphereX, centerY, sphereRadius, 'red', gridWidth, gridHeight);
                            
                            // Draw blue sphere (right)
                            drawGradientSphere(rightSphereX, centerY, sphereRadius, 'blue', gridWidth, gridHeight);
                            
                        } else if (phase === 'eclipse') {
                            // Eclipse/singularity moment - spheres overlap
                            const overlap = phaseProgress * sphereRadius * 0.8;
                            const leftSphereX = centerX - overlap;
                            const rightSphereX = centerX + overlap;
                            
                            // Draw overlapping spheres with increasing intensity
                            drawGradientSphere(leftSphereX, centerY, sphereRadius, 'red', gridWidth, gridHeight);
                            drawGradientSphere(rightSphereX, centerY, sphereRadius, 'blue', gridWidth, gridHeight);
                            
                            // Add eclipse ring effect
                            const ringRadius = sphereRadius * (1.2 + phaseProgress * 0.5);
                            drawEclipseRing(centerX, centerY, ringRadius, phaseProgress, gridWidth, gridHeight);
                            
                        } else if (phase === 'explosion') {
                            // Explosion and flash
                            const explosionRadius = sphereRadius * (1 + phaseProgress * 3);
                            const flashIntensity = Math.sin(phaseProgress * Math.PI * 4) * (1 - phaseProgress);
                            
                            // Draw explosion burst
                            drawExplosion(centerX, centerY, explosionRadius, phaseProgress, flashIntensity, gridWidth, gridHeight);
                            
                            // Flash effect
                            if (flashIntensity > 0.5) {
                                for (let y = 0; y < gridHeight; y++) {
                                    for (let x = 0; x < gridWidth; x++) {
                                        if (Math.random() < 0.3) {
                                            pixelGrid[y][x] = Math.max(pixelGrid[y][x], flashIntensity);
                                        }
                                    }
                                }
                            }
                            
                        } else if (phase === 'fusion') {
                            // Final fused sphere with energy waves
                            const fusedRadius = sphereRadius * (1.5 - phaseProgress * 0.3);
                            const waveIntensity = (1 - phaseProgress) * 0.5;
                            
                            // Draw fused purple/white sphere
                            drawGradientSphere(centerX, centerY, fusedRadius, 'fusion', gridWidth, gridHeight);
                            
                            // Add energy waves
                            const waveRadius = fusedRadius + (phaseProgress * sphereRadius * 2);
                            drawEnergyWaves(centerX, centerY, waveRadius, waveIntensity, gridWidth, gridHeight);
                        }
                        break;
                        
                    case 'blink':
                        const shouldShow = Math.floor(elapsed / 500) % 2 === 0;
                        if (shouldShow) {
                            for (let y = 0; y < pixelGrid.length; y++) {
                                for (let x = 0; x < pixelGrid[y].length; x++) {
                                    pixelGrid[y][x] = originalGrid[y][x];
                                }
                            }
                        } else {
                            for (let y = 0; y < pixelGrid.length; y++) {
                                for (let x = 0; x < pixelGrid[y].length; x++) {
                                    pixelGrid[y][x] = 0;
                                }
                            }
                        }
                        break;
                        
                    case 'laser':
                        // Smooth sweeping laser scan across visible text
                        const totalHeight = pixelGrid.length;
                        const scanCycleTime = 2000; // 2 seconds per complete sweep
                        const currentTime = elapsed % scanCycleTime;
                        const sweepProgress = currentTime / scanCycleTime;
                        
                        // Calculate smooth sweep positions
                        const upwardSweep = sweepProgress * totalHeight; // 0 to height (bottom to top)
                        const downwardSweep = totalHeight - (sweepProgress * totalHeight); // height to 0 (top to bottom)
                        const offsetSweep = ((sweepProgress + 0.33) % 1) * totalHeight; // Offset by 1/3
                        
                        // Start with original text visible but dimmed
                        for (let y = 0; y < pixelGrid.length; y++) {
                            for (let x = 0; x < pixelGrid[y].length; x++) {
                                pixelGrid[y][x] = originalGrid[y][x] * 0.4; // Keep text visible but dim
                            }
                        }
                        
                        // Add sweeping scan lines that brighten the text
                        for (let y = 0; y < pixelGrid.length; y++) {
                            let scanIntensity = 0;
                            
                            // Upward moving bright line
                            const distanceFromUpSweep = Math.abs(y - upwardSweep);
                            if (distanceFromUpSweep < 3) {
                                if (distanceFromUpSweep < 0.5) {
                                    scanIntensity = Math.max(scanIntensity, 1.0); // Brightest center
                                } else if (distanceFromUpSweep < 1.5) {
                                    scanIntensity = Math.max(scanIntensity, 0.8); // Medium glow
                                } else {
                                    scanIntensity = Math.max(scanIntensity, 0.6); // Outer glow
                                }
                            }
                            
                            // Downward moving bright line
                            const distanceFromDownSweep = Math.abs(y - downwardSweep);
                            if (distanceFromDownSweep < 2.5) {
                                if (distanceFromDownSweep < 0.5) {
                                    scanIntensity = Math.max(scanIntensity, 0.9);
                                } else if (distanceFromDownSweep < 1.5) {
                                    scanIntensity = Math.max(scanIntensity, 0.7);
                                }
                            }
                            
                            // Offset sweep line
                            const distanceFromOffsetSweep = Math.abs(y - offsetSweep);
                            if (distanceFromOffsetSweep < 2) {
                                if (distanceFromOffsetSweep < 0.5) {
                                    scanIntensity = Math.max(scanIntensity, 0.8);
                                }
                            }
                            
                            // Apply scan intensity to the entire row
                            if (scanIntensity > 0) {
                                for (let x = 0; x < pixelGrid[y].length; x++) {
                                    // Brighten text where it exists, add scan line everywhere
                                    if (originalGrid[y][x] > 0) {
                                        // Brighten existing text
                                        pixelGrid[y][x] = Math.max(pixelGrid[y][x], originalGrid[y][x] * scanIntensity);
                                    } else {
                                        // Add faint scan line in empty areas
                                        pixelGrid[y][x] = Math.max(pixelGrid[y][x], scanIntensity * 0.3);
                                    }
                                }
                            }
                        }
                        
                        // Add bright white scan lines
                        const whiteLineTime = (elapsed * 1.3) % scanCycleTime;
                        const whiteProgress = whiteLineTime / scanCycleTime;
                        const whiteSweepUp = whiteProgress * totalHeight;
                        const whiteSweepDown = totalHeight - (whiteProgress * totalHeight);
                        
                        // Draw thin bright white lines
                        const whiteY1 = Math.floor(whiteSweepUp);
                        const whiteY2 = Math.floor(whiteSweepDown);
                        
                        if (whiteY1 >= 0 && whiteY1 < pixelGrid.length) {
                            for (let x = 0; x < pixelGrid[whiteY1].length; x++) {
                                pixelGrid[whiteY1][x] = Math.max(pixelGrid[whiteY1][x], 0.95);
                            }
                        }
                        
                        if (whiteY2 >= 0 && whiteY2 < pixelGrid.length) {
                            for (let x = 0; x < pixelGrid[whiteY2].length; x++) {
                                pixelGrid[whiteY2][x] = Math.max(pixelGrid[whiteY2][x], 0.9);
                            }
                        }
                        break;
                        
                    case 'matrix':
                        // Matrix rain animation using custom text
                        const { gridWidth: matrixWidth, gridHeight: matrixHeight } = { gridWidth: pixelGrid[0].length, gridHeight: pixelGrid.length };
                        const customTextForMatrix = document.getElementById('customText').value || 'IONIQ 6 N';
                        const matrixColorScheme = document.getElementById('matrixColor').value;
                        
                        // Clear the screen
                        for (let y = 0; y < matrixHeight; y++) {
                            for (let x = 0; x < matrixWidth; x++) {
                                pixelGrid[y][x] = 0;
                            }
                        }
                        
                        // Matrix rain parameters - reinitialize each time to get fresh text
                        if (!window.matrixColumns || elapsed < 100) {
                            if (window.matrixColumns) delete window.matrixColumns;
                            window.matrixColumns = [];
                            
                            // Split text into words for readable falling
                            const words = customTextForMatrix.trim().split(/\s+/);
                            
                            // Create multiple falling columns with individual characters
                            const columnCount = 25; // Number of falling streams
                            const columnWidth = Math.floor(matrixWidth / columnCount);
                            
                            for (let i = 0; i < columnCount; i++) {
                                window.matrixColumns.push({
                                    x: i * columnWidth + Math.random() * (columnWidth - 4),
                                    y: Math.random() * -matrixHeight,
                                    speed: 0.5 + Math.random() * 1.0,
                                    trail: [],
                                    brightness: 0.8 + Math.random() * 0.2,
                                    words: words,
                                    currentWordIndex: Math.floor(Math.random() * words.length),
                                    currentCharIndex: 0
                                });
                            }
                        }
                        
                        // Update matrix columns
                        for (let col of window.matrixColumns) {
                            // Move column down
                            col.y += col.speed;
                            
                            // Reset column when it goes off screen
                            if (col.y > matrixHeight + 20) {
                                col.y = Math.random() * -30 - 20;
                                col.speed = 0.5 + Math.random() * 1.0;
                                col.trail = [];
                                col.brightness = 0.8 + Math.random() * 0.2;
                                col.currentWordIndex = Math.floor(Math.random() * col.words.length);
                                col.currentCharIndex = 0;
                            }
                            
                            // Get current character from current word
                            const currentWord = col.words[col.currentWordIndex];
                            const currentChar = currentWord[col.currentCharIndex];
                            
                            // Move to next character occasionally
                            if (Math.random() < 0.1) {
                                col.currentCharIndex++;
                                if (col.currentCharIndex >= currentWord.length) {
                                    col.currentCharIndex = 0;
                                    col.currentWordIndex = (col.currentWordIndex + 1) % col.words.length;
                                }
                            }
                            
                            // Update trail
                            col.trail.unshift({ y: col.y, char: currentChar });
                            if (col.trail.length > 15) {
                                col.trail.pop();
                            }
                            
                            // Draw the trail
                            for (let i = 0; i < col.trail.length; i++) {
                                const trailChar = col.trail[i];
                                const charY = Math.floor(trailChar.y - i * 6);
                                
                                if (charY >= 0 && charY < matrixHeight - 5) {
                                    const char = trailChar.char ? trailChar.char.toUpperCase() : ' ';
                                    const charData = smallPixelFont[char];
                                    
                                    if (charData) {
                                        // Calculate brightness
                                        let brightness;
                                        if (i === 0) {
                                            brightness = col.brightness;
                                        } else {
                                            brightness = Math.max(0.1, (1 - i / col.trail.length) * 0.8);
                                        }
                                        
                                        // Draw character (3x5)
                                        for (let y = 0; y < 5; y++) {
                                            for (let x = 0; x < 3; x++) {
                                                const pixelX = Math.floor(col.x) + x;
                                                const pixelY = charY + y;
                                                
                                                if (pixelX < matrixWidth && pixelY < matrixHeight && pixelX >= 0 && pixelY >= 0) {
                                                    if (charData[y] && charData[y][x]) {
                                                        let pixelValue;
                                                        
                                                        if (i === 0) {
                                                            // Leading character in white
                                                            const whiteLevels = colorThemes.white.levels;
                                                            const levelIndex = Math.floor(brightness * (whiteLevels.length - 1));
                                                            const color = whiteLevels[Math.min(levelIndex, whiteLevels.length - 1)];
                                                            
                                                            pixelValue = {
                                                                isSpecialColor: true,
                                                                color: color,
                                                                intensity: brightness
                                                            };
                                                        } else {
                                                            // Trail characters in selected color scheme
                                                            const selectedLevels = colorThemes[matrixColorScheme].levels;
                                                            const levelIndex = Math.floor(brightness * (selectedLevels.length - 1));
                                                            const color = selectedLevels[Math.min(levelIndex, selectedLevels.length - 1)];
                                                            
                                                            pixelValue = {
                                                                isSpecialColor: true,
                                                                color: color,
                                                                intensity: brightness
                                                            };
                                                        }
                                                        
                                                        // Only set if brighter than existing pixel
                                                        if (!pixelGrid[pixelY][pixelX] || (pixelGrid[pixelY][pixelX].intensity || 0) < brightness) {
                                                            pixelGrid[pixelY][pixelX] = pixelValue;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 'equalizer':
                        // Graphic Equalizer Animation
                        const { gridWidth: eqWidth, gridHeight: eqHeight } = { gridWidth: pixelGrid[0].length, gridHeight: pixelGrid.length };
                        
                        // Clear the screen
                        for (let y = 0; y < eqHeight; y++) {
                            for (let x = 0; x < eqWidth; x++) {
                                pixelGrid[y][x] = 0;
                            }
                        }
                        
                        // Initialize equalizer bars if needed
                        if (!window.equalizerBars) {
                            window.equalizerBars = [];
                            const pairCount = 20; // Number of red/blue pairs
                            const barWidth = 2; // Width of each individual bar
                            const pairSpacing = 4; // Space between pairs
                            const totalWidth = pairCount * (barWidth * 2 + pairSpacing) - pairSpacing;
                            const startX = Math.floor((eqWidth - totalWidth) / 2);
                            
                            for (let i = 0; i < pairCount; i++) {
                                const pairX = startX + i * (barWidth * 2 + pairSpacing);
                                const frequency = i / (pairCount - 1); // 0 to 1
                                
                                // Red bar (left in each pair)
                                window.equalizerBars.push({
                                    x: pairX,
                                    width: barWidth,
                                    currentHeight: 0,
                                    targetHeight: 0,
                                    peakHeight: 0,
                                    peakDecay: 0,
                                    frequency: frequency,
                                    colorType: 'red',
                                    // Red bars respond more to rhythm and bass
                                    bassResponse: Math.max(0.3, 1.2 - (frequency * 1.5)),
                                    midResponse: frequency > 0.2 && frequency < 0.7 ? 0.8 : 0.3,
                                    trebleResponse: frequency > 0.6 ? 0.9 : 0.2,
                                    // Red bars are more aggressive - quick rise and fall
                                    riseSpeed: 0.95,
                                    fallSpeed: 0.75,
                                    sensitivity: 1.4
                                });
                                
                                // Blue bar (right in each pair)
                                window.equalizerBars.push({
                                    x: pairX + barWidth,
                                    width: barWidth,
                                    currentHeight: 0,
                                    targetHeight: 0,
                                    peakHeight: 0,
                                    peakDecay: 0,
                                    frequency: frequency,
                                    colorType: 'blue',
                                    // Blue bars respond more to melody and harmonics
                                    bassResponse: frequency < 0.4 ? 0.6 : 0.2,
                                    midResponse: frequency > 0.3 && frequency < 0.8 ? 1.1 : 0.4,
                                    trebleResponse: frequency > 0.5 ? 1.3 : 0.3,
                                    // Blue bars are smoother - slower rise and fall
                                    riseSpeed: 0.6,
                                    fallSpeed: 0.9,
                                    sensitivity: 1.0
                                });
                            }
                        }
                        
                        // Simulate pop music with more complex characteristics
                        const time = elapsed / 1000;
                        const beatFreq = 2.3; // Slightly faster tempo
                        
                        // Multiple musical elements with different timings
                        const kickDrum = Math.max(0, Math.sin(time * beatFreq * Math.PI * 2)) * 0.9;
                        const snare = Math.max(0, Math.sin((time - 0.22) * beatFreq * Math.PI * 2)) * 0.7; // Offset snare
                        const hiHat = Math.sin(time * beatFreq * 8 * Math.PI * 2) * 0.4 + 0.4;
                        const bassLine = Math.sin(time * beatFreq * 0.5 * Math.PI * 2) * 0.6 + 0.5; // Slower bass
                        const vocals = Math.sin(time * 0.8 * Math.PI * 2) * 0.5 + 0.5;
                        const synth = Math.sin(time * 1.3 * Math.PI * 2) * 0.4 + 0.3;
                        const cymbal = Math.max(0, Math.sin(time * 0.25 * Math.PI * 2)) * 0.8; // Occasional crash
                        
                        // Add musical variations
                        const breakdown = Math.sin(time * 0.1 * Math.PI * 2) > 0.8 ? 0.3 : 1.0; // Occasional quiet parts
                        const buildup = Math.max(0, Math.sin(time * 0.05 * Math.PI * 2)) * 0.5 + 0.5; // Slow build
                        
                        // Update each bar with different responses
                        for (let bar of window.equalizerBars) {
                            let intensity = 0;
                            const randomFactor = (Math.random() - 0.5) * 0.4;
                            
                            // Bass frequencies (0-0.3)
                            if (bar.frequency <= 0.3) {
                                if (bar.colorType === 'red') {
                                    // Red bars: Aggressive response to drums
                                    intensity = (kickDrum * 1.2 + bassLine * 0.8) * bar.bassResponse;
                                    intensity += snare * 0.6; // Strong snare response
                                } else {
                                    // Blue bars: Smoother bass response
                                    intensity = bassLine * bar.bassResponse * 0.9;
                                    intensity += kickDrum * 0.4; // Gentler kick response
                                }
                            }
                            // Mid-low frequencies (0.3-0.6)
                            else if (bar.frequency <= 0.6) {
                                if (bar.colorType === 'red') {
                                    // Red bars: Punchy mids, strong snare
                                    intensity = (snare * 1.4 + vocals * 0.6 + synth * 0.8) * bar.midResponse;
                                    intensity += cymbal * 0.9;
                                } else {
                                    // Blue bars: Melodic content
                                    intensity = (vocals * 1.1 + synth * 1.2 + bassLine * 0.4) * bar.midResponse;
                                }
                            }
                            // High frequencies (0.6-1.0)
                            else {
                                if (bar.colorType === 'red') {
                                    // Red bars: Sharp, aggressive highs
                                    intensity = (hiHat * 1.3 + cymbal * 1.5 + snare * 0.4) * bar.trebleResponse;
                                    // Add some sparkle
                                    intensity += Math.sin(time * 5.7 * Math.PI * 2) * 0.3;
                                } else {
                                    // Blue bars: Smooth, harmonic highs
                                    intensity = (vocals * 0.8 + synth * 0.9 + hiHat * 0.7) * bar.trebleResponse;
                                    // Add harmonic overtones
                                    intensity += Math.sin(time * 2.1 * Math.PI * 2) * 0.2;
                                }
                            }
                            
                            // Apply musical effects
                            intensity *= breakdown * buildup;
                            intensity += randomFactor;
                            intensity *= bar.sensitivity;
                            
                            // More dramatic height variations
                            intensity = Math.max(0, Math.min(1.8, intensity)); // Allow heights above 1.0
                            bar.targetHeight = intensity * (eqHeight - 2);
                            
                            // Different rise/fall speeds for red vs blue
                            if (bar.targetHeight > bar.currentHeight) {
                                // Rising - use rise speed
                                bar.currentHeight = bar.currentHeight * (1 - bar.riseSpeed) + bar.targetHeight * bar.riseSpeed;
                            } else {
                                // Falling - use fall speed  
                                bar.currentHeight = bar.currentHeight * bar.fallSpeed + bar.targetHeight * (1 - bar.fallSpeed);
                            }
                            
                            // Enhanced peak hold with different decay rates
                            if (bar.currentHeight > bar.peakHeight) {
                                bar.peakHeight = bar.currentHeight;
                                bar.peakDecay = 0;
                            } else {
                                // Different decay rates for red vs blue
                                const decayRate = bar.colorType === 'red' ? 0.025 : 0.015;
                                bar.peakDecay += decayRate;
                                bar.peakHeight = Math.max(bar.currentHeight, bar.peakHeight - bar.peakDecay);
                            }
                        }
                        
                        // Draw the equalizer bars
                        for (let bar of window.equalizerBars) {
                            const barHeight = Math.floor(bar.currentHeight);
                            const peakY = Math.floor(eqHeight - bar.peakHeight - 1);
                            
                            // Choose color palette
                            const colorPalette = bar.colorType === 'blue' ? colorThemes.blue : colorThemes.red;
                            
                            // Draw main bar from bottom up
                            for (let y = 0; y < barHeight; y++) {
                                for (let x = 0; x < bar.width; x++) {
                                    const pixelX = bar.x + x;
                                    const pixelY = eqHeight - 1 - y; // Draw from bottom
                                    
                                    if (pixelX < eqWidth && pixelY >= 0 && pixelY < eqHeight) {
                                        // Calculate intensity based on height position
                                        const heightRatio = y / Math.max(1, barHeight);
                                        let intensity;
                                        
                                        // Gradient effect - brighter at top
                                        if (heightRatio > 0.8) {
                                            intensity = 0.9 + heightRatio * 0.1; // Very bright at top
                                        } else if (heightRatio > 0.6) {
                                            intensity = 0.7 + heightRatio * 0.2; // Bright
                                        } else if (heightRatio > 0.3) {
                                            intensity = 0.5 + heightRatio * 0.2; // Medium
                                        } else {
                                            intensity = 0.3 + heightRatio * 0.2; // Dim at bottom
                                        }
                                        
                                        const levelIndex = Math.floor(intensity * (colorPalette.levels.length - 1));
                                        const color = colorPalette.levels[Math.min(levelIndex, colorPalette.levels.length - 1)];
                                        
                                        const pixelValue = {
                                            isSpecialColor: true,
                                            color: color,
                                            intensity: intensity
                                        };
                                        
                                        pixelGrid[pixelY][pixelX] = pixelValue;
                                    }
                                }
                            }
                            
                            // Draw peak indicator (bright white dot)
                            if (bar.peakHeight > 2) {
                                for (let x = 0; x < bar.width; x++) {
                                    const pixelX = bar.x + x;
                                    
                                    if (pixelX < eqWidth && peakY >= 0 && peakY < eqHeight) {
                                        const whiteLevels = colorThemes.white.levels;
                                        const peakColor = whiteLevels[whiteLevels.length - 1]; // Brightest white
                                        
                                        const peakPixel = {
                                            isSpecialColor: true,
                                            color: peakColor,
                                            intensity: 1.0
                                        };
                                        
                                        pixelGrid[peakY][pixelX] = peakPixel;
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 'glitch':
                        // Reset to original
                        for (let y = 0; y < pixelGrid.length; y++) {
                            for (let x = 0; x < pixelGrid[y].length; x++) {
                                pixelGrid[y][x] = originalGrid[y][x];
                            }
                        }
                        
                        // Add glitch effects
                        if (Math.floor(elapsed / 150) % 3 !== 0) {
                            for (let y = 0; y < pixelGrid.length; y++) {
                                for (let x = 0; x < pixelGrid[y].length; x++) {
                                    if (originalGrid[y][x] > 0 && Math.random() < 0.15) {
                                        if (Math.random() < 0.5) {
                                            pixelGrid[y][x] = 0;
                                        } else {
                                            pixelGrid[y][x] = Math.random();
                                        }
                                    }
                                    if (originalGrid[y][x] === 0 && Math.random() < 0.05) {
                                        pixelGrid[y][x] = Math.random() * 0.7;
                                    }
                                }
                            }
                        }
                        break;
                }
                
                drawPixelGrid();
                animationFrame = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        function pauseAnimation() {
            if (isAnimating) {
                isAnimating = false;
                cancelAnimationFrame(animationFrame);
                
                // Update button visibility
                document.getElementById('animateBtn').style.display = 'inline-block';
                document.getElementById('pauseBtn').style.display = 'none';
                
                updateStatus('Animation paused - current frame preserved');
            }
        }
        
        function saveAsImage() {
            const link = document.createElement('a');
            link.download = `pixel-art-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
            updateStatus('Image saved!');
        }
        
        function drawGradientSphere(centerX, centerY, radius, colorType, gridWidth, gridHeight) {
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < radius) {
                        const z = Math.sqrt(Math.max(0, radius * radius - dx * dx - dy * dy));
                        const normal = {
                            x: dx / radius,
                            y: dy / radius,
                            z: z / radius
                        };
                        
                        const light = { x: 0.5, y: -0.5, z: 0.7 };
                        const dot = normal.x * light.x + normal.y * light.y + normal.z * light.z;
                        let intensity = Math.max(0, dot) * 0.8 + 0.2;
                        
                        // Create pixel with specific color information
                        let pixelValue;
                        
                        if (colorType === 'red') {
                            // Red sphere - use red color palette
                            const redLevels = colorThemes.red.levels;
                            const levelIndex = Math.floor(intensity * (redLevels.length - 1));
                            const color = redLevels[Math.min(levelIndex, redLevels.length - 1)];
                            
                            pixelValue = {
                                isSpecialColor: true,
                                color: color,
                                intensity: intensity
                            };
                        } else if (colorType === 'blue') {
                            // Blue sphere - use blue color palette
                            const blueLevels = colorThemes.blue.levels;
                            const levelIndex = Math.floor(intensity * (blueLevels.length - 1));
                            const color = blueLevels[Math.min(levelIndex, blueLevels.length - 1)];
                            
                            pixelValue = {
                                isSpecialColor: true,
                                color: color,
                                intensity: intensity
                            };
                        } else if (colorType === 'fusion') {
                            // Fusion sphere - bright white/purple
                            const whiteLevels = colorThemes.white.levels;
                            const levelIndex = Math.floor((intensity * 1.2) * (whiteLevels.length - 1));
                            const color = whiteLevels[Math.min(levelIndex, whiteLevels.length - 1)];
                            
                            pixelValue = {
                                isSpecialColor: true,
                                color: color,
                                intensity: intensity * 1.2
                            };
                        }
                        
                        // Only set if this pixel is brighter than what's already there
                        if (!pixelGrid[y][x] || (pixelGrid[y][x].intensity || 0) < intensity) {
                            pixelGrid[y][x] = pixelValue;
                        }
                    }
                }
            }
        }
        
        function drawEclipseRing(centerX, centerY, radius, progress, gridWidth, gridHeight) {
            const ringThickness = 3;
            const intensity = 0.8 + Math.sin(progress * Math.PI * 6) * 0.2;
            
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (Math.abs(dist - radius) < ringThickness) {
                        const ringIntensity = intensity * (1 - Math.abs(dist - radius) / ringThickness);
                        
                        // Create eclipse ring with white color
                        const whiteLevels = colorThemes.white.levels;
                        const levelIndex = Math.floor(ringIntensity * (whiteLevels.length - 1));
                        const color = whiteLevels[Math.min(levelIndex, whiteLevels.length - 1)];
                        
                        const pixelValue = {
                            isSpecialColor: true,
                            color: color,
                            intensity: ringIntensity
                        };
                        
                        if (!pixelGrid[y][x] || (pixelGrid[y][x].intensity || 0) < ringIntensity) {
                            pixelGrid[y][x] = pixelValue;
                        }
                    }
                }
            }
        }
        
        function drawExplosion(centerX, centerY, radius, progress, flashIntensity, gridWidth, gridHeight) {
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < radius) {
                        // Explosion burst pattern
                        const angle = Math.atan2(dy, dx);
                        const burstPattern = Math.sin(angle * 8) * 0.3 + 0.7;
                        const distanceFactor = 1 - (dist / radius);
                        const intensity = distanceFactor * burstPattern * (0.8 + flashIntensity * 0.4);
                        
                        // Create explosion pixel with white/bright color
                        const whiteLevels = colorThemes.white.levels;
                        const levelIndex = Math.floor(intensity * (whiteLevels.length - 1));
                        const color = whiteLevels[Math.min(levelIndex, whiteLevels.length - 1)];
                        
                        const pixelValue = {
                            isSpecialColor: true,
                            color: color,
                            intensity: intensity
                        };
                        
                        // Add random sparks
                        if (Math.random() < 0.1) {
                            pixelValue.intensity = Math.min(1, intensity + Math.random() * 0.3);
                            const sparkIndex = Math.floor(pixelValue.intensity * (whiteLevels.length - 1));
                            pixelValue.color = whiteLevels[Math.min(sparkIndex, whiteLevels.length - 1)];
                        }
                        
                        if (!pixelGrid[y][x] || (pixelGrid[y][x].intensity || 0) < pixelValue.intensity) {
                            pixelGrid[y][x] = pixelValue;
                        }
                    }
                }
            }
        }
        
        function drawEnergyWaves(centerX, centerY, radius, intensity, gridWidth, gridHeight) {
            const waveCount = 3;
            
            for (let wave = 0; wave < waveCount; wave++) {
                const waveRadius = radius - (wave * 8);
                const waveThickness = 2;
                const waveIntensity = intensity * (1 - wave * 0.3);
                
                if (waveRadius > 0) {
                    for (let y = 0; y < gridHeight; y++) {
                        for (let x = 0; x < gridWidth; x++) {
                            const dx = x - centerX;
                            const dy = y - centerY;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (Math.abs(dist - waveRadius) < waveThickness) {
                                const currentWaveIntensity = waveIntensity * (1 - Math.abs(dist - waveRadius) / waveThickness);
                                
                                // Create wave pixel with white color
                                const whiteLevels = colorThemes.white.levels;
                                const levelIndex = Math.floor(currentWaveIntensity * (whiteLevels.length - 1));
                                const color = whiteLevels[Math.min(levelIndex, whiteLevels.length - 1)];
                                
                                const pixelValue = {
                                    isSpecialColor: true,
                                    color: color,
                                    intensity: currentWaveIntensity
                                };
                                
                                if (!pixelGrid[y][x] || (pixelGrid[y][x].intensity || 0) < currentWaveIntensity) {
                                    pixelGrid[y][x] = pixelValue;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Initialize
        initDisplay();
        generatePattern();
        updateStatus('Ready to create retro-future graphics!');
    </script>
</body>
</html>
