<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RETRO-FUTURE GRAPHIC ANIMATOR</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Inter', system-ui, sans-serif;
            background: #000000;
            color: #ffffff;
            min-height: 100vh;
            font-weight: 400;
            letter-spacing: -0.01em;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 32px;
            border-bottom: 1px solid #1a1a1a;
            padding-bottom: 24px;
        }
        
        .header h1 {
            font-size: 1.75rem;
            font-weight: 500;
            color: #ffffff;
            margin-bottom: 4px;
            letter-spacing: -0.02em;
        }
        
        .header .subtitle {
            font-size: 0.75rem;
            color: #888888;
            font-weight: 400;
            letter-spacing: 0.1em;
        }
        
        .control-panel {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
        }
        
        .control-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-row-2 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .control-group label {
            font-weight: 500;
            color: #ffffff;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .control-group input,
        .control-group select {
            padding: 8px 12px;
            border: 1px solid #333333;
            border-radius: 4px;
            font-size: 0.875rem;
            background: #000000;
            color: #ffffff;
            transition: border-color 0.15s ease;
        }
        
        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #00ffff;
        }
        
        .action-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .btn {
            padding: 8px 16px;
            border: 1px solid #333333;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            background: #000000;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .btn:hover {
            border-color: #00ffff;
            color: #00ffff;
        }
        
        .btn-primary {
            background: #00ffff;
            color: #000000;
            border-color: #00ffff;
        }
        
        .btn-primary:hover {
            background: #ffffff;
            border-color: #ffffff;
        }
        
        .status {
            text-align: center;
            padding: 12px 16px;
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            margin: 16px 0;
            font-size: 0.875rem;
            color: #888888;
        }
        
        .canvas-container {
            display: flex;
            justify-content: center;
            margin: 32px 0;
        }
        
        canvas {
            border: 1px solid #333333;
            border-radius: 4px;
            background: #000000;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .footer {
            text-align: center;
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid #1a1a1a;
            color: #888888;
            font-size: 0.75rem;
        }
        
        .footer .absai-logo {
            display: inline-block;
            margin: 8px 0;
        }
        
        .footer .absai-logo img {
            height: 60px;
            width: auto;
            max-width: 200px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>RETRO-FUTURE GRAPHIC ANIMATOR</h1>
            <div class="subtitle">Built by ABSAI</div>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group">
                    <label>Pattern</label>
                    <select id="pattern">
                        <option value="text" selected>Text Display</option>
                        <option value="heart">Heart</option>
                        <option value="dots">Random Dots</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Custom Text</label>
                    <input type="text" id="customText" placeholder="Enter your text..." value="IONIQ 6 N">
                </div>
                
                <div class="control-group">
                    <label>Color Scheme</label>
                    <select id="baseColor">
                        <option value="red" selected>N Red</option>
                        <option value="blue">Perf Blue</option>
                        <option value="white">White/Gray</option>
                        <option value="green">Matrix Green</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Duration</label>
                    <select id="duration">
                        <option value="3" selected>3s</option>
                        <option value="5">5s</option>
                        <option value="10">10s</option>
                    </select>
                </div>
            </div>
            
            <div class="control-row-2">
                <div class="control-group">
                    <label>Animation</label>
                    <select id="animation">
                        <option value="none">Static</option>
                        <option value="pulse">Pulse</option>
                        <option value="blink">Blink</option>
                        <option value="glitch">Glitch</option>
                        <option value="laser">Laser Scan</option>
                        <option value="collision">Sphere Collision</option>
                        <option value="matrix">Matrix Rain</option>
                        <option value="equalizer">Graphic Equalizer</option>
                        <option value="heartbeat">Heartbeat</option>
                        <option value="countdown">Countdown Clock</option>
                        <option value="dots_flicker">Dots Flicker</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Matrix Rain Color</label>
                    <select id="matrixColor">
                        <option value="green" selected>Classic Green</option>
                        <option value="blue">Perf. Blue</option>
                        <option value="red">N Red</option>
                        <option value="white">Pure White</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Countdown (HH:MM:SS)</label>
                    <input type="text" id="countdownTime" placeholder="00:03:00" value="00:03:00">
                </div>
                
                <div class="control-group">
                    <!-- Empty for spacing -->
                </div>
            </div>
            
            <div class="action-buttons">
                <button class="btn btn-primary" onclick="generatePattern()">Generate</button>
                <button class="btn" onclick="animateDisplay()" id="animateBtn">Animate</button>
                <button class="btn" onclick="pauseAnimation()" id="pauseBtn" style="display: none;">Pause</button>
                <button class="btn" onclick="saveAsImage()">Save PNG</button>
            </div>
        </div>
        
        <div class="status" id="status">Ready to create pixel art!</div>
        
        <div class="canvas-container">
            <canvas id="canvas" width="800" height="400"></canvas>
        </div>
        
        <div class="footer">
            <div>Built using AI vibe coding by Simon Woollard - June 07 2025</div>
            <div class="absai-logo">
                <img src="absai-logo.png" alt="ABSAI Logo" style="border: 1px solid #333; background: #111; padding: 10px;" />
                <div style="font-size: 0.7rem; color: #666; margin-top: 4px;">Drop your ABSAI logo here</div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let pixelGrid = [];
        let isAnimating = false;
        let animationFrame = null;
        let countdownStartTime = null;
        let countdownDuration = 0;
        
        // Constants
        const PIXEL_SIZE = 4;
        const PIXEL_GAP = 1;
        
        // Color themes
        const colorThemes = {
            red: {
                levels: ['#000000', '#140000', '#280000', '#3c0000', '#500000', '#640000', '#780000', '#8c0000', '#a00000', '#b41414', '#c82828', '#dc3c3c', '#f05050']
            },
            blue: {
                levels: ['#000000', '#0a0f14', '#141e28', '#1e2d3c', '#283c50', '#324b64', '#3c5a78', '#46698c', '#5078a0', '#6487b4', '#7896c8', '#8ca5dc', '#aacae6']
            },
            white: {
                levels: ['#000000', '#111111', '#222222', '#333333', '#444444', '#555555', '#666666', '#777777', '#888888', '#999999', '#aaaaaa', '#cccccc', '#ffffff']
            },
            green: {
                levels: ['#000000', '#0a1a0a', '#143314', '#1e4d1e', '#286628', '#328032', '#3c993c', '#46b346', '#50cc50', '#64dc64', '#78e678', '#8cf08c', '#a6ffa6']
            }
        };
        
        // 3x5 pixel font (smaller for matrix rain)
        const smallPixelFont = {
            'A': [[0,1,0],[1,0,1],[1,1,1],[1,0,1],[1,0,1]],
            'B': [[1,1,0],[1,0,1],[1,1,0],[1,0,1],[1,1,0]],
            'C': [[0,1,1],[1,0,0],[1,0,0],[1,0,0],[0,1,1]],
            'D': [[1,1,0],[1,0,1],[1,0,1],[1,0,1],[1,1,0]],
            'E': [[1,1,1],[1,0,0],[1,1,0],[1,0,0],[1,1,1]],
            'F': [[1,1,1],[1,0,0],[1,1,0],[1,0,0],[1,0,0]],
            'G': [[0,1,1],[1,0,0],[1,0,1],[1,0,1],[0,1,1]],
            'H': [[1,0,1],[1,0,1],[1,1,1],[1,0,1],[1,0,1]],
            'I': [[1,1,1],[0,1,0],[0,1,0],[0,1,0],[1,1,1]],
            'J': [[0,0,1],[0,0,1],[0,0,1],[1,0,1],[0,1,0]],
            'K': [[1,0,1],[1,1,0],[1,0,0],[1,1,0],[1,0,1]],
            'L': [[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,1,1]],
            'M': [[1,0,1],[1,1,1],[1,0,1],[1,0,1],[1,0,1]],
            'N': [[1,0,1],[1,1,1],[1,0,1],[1,0,1],[1,0,1]],
            'O': [[0,1,0],[1,0,1],[1,0,1],[1,0,1],[0,1,0]],
            'P': [[1,1,0],[1,0,1],[1,1,0],[1,0,0],[1,0,0]],
            'Q': [[0,1,0],[1,0,1],[1,1,1],[0,1,1],[0,0,1]],
            'R': [[1,1,0],[1,0,1],[1,1,0],[1,0,1],[1,0,1]],
            'S': [[0,1,1],[1,0,0],[0,1,0],[0,0,1],[1,1,0]],
            'T': [[1,1,1],[0,1,0],[0,1,0],[0,1,0],[0,1,0]],
            'U': [[1,0,1],[1,0,1],[1,0,1],[1,0,1],[0,1,0]],
            'V': [[1,0,1],[1,0,1],[1,0,1],[1,0,1],[0,1,0]],
            'W': [[1,0,1],[1,0,1],[1,0,1],[1,1,1],[1,0,1]],
            'X': [[1,0,1],[0,1,0],[0,1,0],[0,1,0],[1,0,1]],
            'Y': [[1,0,1],[1,0,1],[0,1,0],[0,1,0],[0,1,0]],
            'Z': [[1,1,1],[0,0,1],[0,1,0],[1,0,0],[1,1,1]],
            '0': [[0,1,0],[1,0,1],[1,0,1],[1,0,1],[0,1,0]],
            '1': [[0,1,0],[1,1,0],[0,1,0],[0,1,0],[1,1,1]],
            '2': [[0,1,0],[1,0,1],[0,1,0],[1,0,0],[1,1,1]],
            '3': [[1,1,0],[0,0,1],[0,1,0],[0,0,1],[1,1,0]],
            '4': [[1,0,1],[1,0,1],[1,1,1],[0,0,1],[0,0,1]],
            '5': [[1,1,1],[1,0,0],[1,1,0],[0,0,1],[1,1,0]],
            '6': [[0,1,1],[1,0,0],[1,1,0],[1,0,1],[0,1,0]],
            '7': [[1,1,1],[0,0,1],[0,1,0],[0,1,0],[0,1,0]],
            '8': [[0,1,0],[1,0,1],[0,1,0],[1,0,1],[0,1,0]],
            '9': [[0,1,0],[1,0,1],[0,1,1],[0,0,1],[1,1,0]],
            ' ': [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]],
            '?': [[0,1,0],[1,0,1],[0,1,0],[0,0,0],[0,1,0]],
            '!': [[0,1,0],[0,1,0],[0,1,0],[0,0,0],[0,1,0]],
            '.': [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,1,0]],
            ':': [[0,0,0],[0,1,0],[0,0,0],[0,1,0],[0,0,0]],
            '-': [[0,0,0],[0,0,0],[1,1,1],[0,0,0],[0,0,0]]
        };
        
        // 5x7 pixel font (original size)
        const pixelFont = {
            'A': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
            'B': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0]],
            'C': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,1],[0,1,1,1,0]],
            'D': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0]],
            'E': [[1,1,1,1,1],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
            'F': [[1,1,1,1,1],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]],
            'G': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'H': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
            'I': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1]],
            'J': [[0,0,1,1,1],[0,0,0,1,0],[0,0,0,1,0],[0,0,0,1,0],[0,0,0,1,0],[1,0,0,1,0],[0,1,1,0,0]],
            'K': [[1,0,0,0,1],[1,0,0,1,0],[1,0,1,0,0],[1,1,0,0,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]],
            'L': [[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
            'M': [[1,0,0,0,1],[1,1,0,1,1],[1,0,1,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
            'N': [[1,0,0,0,1],[1,1,0,0,1],[1,0,1,0,1],[1,0,0,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
            'O': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'P': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]],
            'Q': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,1,0],[0,1,1,0,1]],
            'R': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]],
            'S': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[0,1,1,1,0],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'T': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
            'U': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'V': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0]],
            'W': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,1,0,1],[1,1,0,1,1],[1,0,0,0,1]],
            'X': [[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1],[1,0,0,0,1]],
            'Y': [[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
            'Z': [[1,1,1,1,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
            '0': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,1,1],[1,0,1,0,1],[1,1,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            '1': [[0,0,1,0,0],[0,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1]],
            '2': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,1,1,1,1]],
            '3': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,1,1,0],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            '4': [[0,0,0,1,0],[0,0,1,1,0],[0,1,0,1,0],[1,0,0,1,0],[1,1,1,1,1],[0,0,0,1,0],[0,0,0,1,0]],
            '5': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,0],[0,0,0,0,1],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            '6': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            '7': [[1,1,1,1,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[0,1,0,0,0],[0,1,0,0,0]],
            '8': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            '9': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,1],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            ' ': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],
            '?': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,1,0,0]],
            '!': [[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,1,0,0]],
            '.': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,1,1,0,0],[0,1,1,0,0]],
            ':': [[0,0,0,0,0],[0,1,1,0,0],[0,1,1,0,0],[0,0,0,0,0],[0,1,1,0,0],[0,1,1,0,0],[0,0,0,0,0]],
            '-': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]
        };
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        function initDisplay() {
            const gridWidth = Math.floor(canvas.width / (PIXEL_SIZE + PIXEL_GAP));
            const gridHeight = Math.floor(canvas.height / (PIXEL_SIZE + PIXEL_GAP));
            
            pixelGrid = [];
            for (let y = 0; y < gridHeight; y++) {
                pixelGrid[y] = [];
                for (let x = 0; x < gridWidth; x++) {
                    pixelGrid[y][x] = 0;
                }
            }
            
            return { gridWidth, gridHeight };
        }
        
        function drawPixelGrid() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const baseColor = document.getElementById('baseColor').value;
            const palette = colorThemes[baseColor] || colorThemes.red;
            
            for (let y = 0; y < pixelGrid.length; y++) {
                for (let x = 0; x < pixelGrid[y].length; x++) {
                    const pixel = pixelGrid[y][x];
                    
                    if (pixel && pixel !== 0) {
                        let color;
                        
                        if (pixel.isSpecialColor) {
                            color = pixel.color;
                        } else {
                            const intensity = Math.floor(pixel * (palette.levels.length - 1));
                            color = palette.levels[Math.min(intensity, palette.levels.length - 1)];
                        }
                        
                        ctx.fillStyle = color;
                        const pixelX = x * (PIXEL_SIZE + PIXEL_GAP);
                        const pixelY = y * (PIXEL_SIZE + PIXEL_GAP);
                        ctx.fillRect(pixelX, pixelY, PIXEL_SIZE, PIXEL_SIZE);
                    }
                }
            }
        }
        
        function parseTimeInput(timeString) {
            // Parse HH:MM:SS, MM:SS, or SS formats
            const parts = timeString.split(':');
            let totalSeconds = 0;
            
            if (parts.length === 3) {
                // HH:MM:SS
                const hours = parseInt(parts[0]) || 0;
                const minutes = parseInt(parts[1]) || 0;
                const seconds = parseInt(parts[2]) || 0;
                totalSeconds = hours * 3600 + minutes * 60 + seconds;
            } else if (parts.length === 2) {
                // MM:SS
                const minutes = parseInt(parts[0]) || 0;
                const seconds = parseInt(parts[1]) || 0;
                totalSeconds = minutes * 60 + seconds;
            } else if (parts.length === 1) {
                // SS
                totalSeconds = parseInt(parts[0]) || 0;
            } else {
                totalSeconds = 180; // Default 3 minutes
            }
            
            return totalSeconds;
        }
        
        function formatTime(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            if (hours > 0) {
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }
        
        function generateTextPattern(text) {
            const { gridWidth, gridHeight } = initDisplay();
            
            // Handle long text - split at 15 characters
            if (text.length > 15) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                
                for (let word of words) {
                    const testLine = currentLine ? currentLine + ' ' + word : word;
                    if (testLine.length > 15) {
                        if (currentLine) {
                            lines.push(currentLine);
                            currentLine = word;
                        } else {
                            lines.push(word.substring(0, 15));
                            currentLine = word.substring(15);
                        }
                    } else {
                        currentLine = testLine;
                    }
                }
                if (currentLine) lines.push(currentLine);
                
                // Draw multi-line text
                const charWidth = 5;
                const charHeight = 7;
                const charSpacing = 2;
                const lineSpacing = 3;
                
                const totalHeight = lines.length * charHeight + (lines.length - 1) * lineSpacing;
                const startY = Math.max(0, Math.floor((gridHeight - totalHeight) / 2));
                
                for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                    const line = lines[lineIndex];
                    const lineWidth = line.length * (charWidth + charSpacing) - charSpacing;
                    const lineStartX = Math.max(0, Math.floor((gridWidth - lineWidth) / 2));
                    const lineY = startY + lineIndex * (charHeight + lineSpacing);
                    
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i].toUpperCase();
                        const charData = pixelFont[char];
                        
                        if (charData) {
                            const charX = lineStartX + i * (charWidth + charSpacing);
                            
                            for (let y = 0; y < charHeight; y++) {
                                for (let x = 0; x < charWidth; x++) {
                                    const pixelX = charX + x;
                                    const pixelY = lineY + y;
                                    
                                    if (pixelX < gridWidth && pixelY < gridHeight && pixelX >= 0 && pixelY >= 0) {
                                        pixelGrid[pixelY][pixelX] = charData[y][x];
                                    }
                                }
                            }
                        }
                    }
                }
                return;
            }
            
            // Single line text
            const charWidth = 5;
            const charHeight = 7;
            const charSpacing = 2;
            
            const totalWidth = text.length * (charWidth + charSpacing) - charSpacing;
            const startX = Math.max(0, Math.floor((gridWidth - totalWidth) / 2));
            const startY = Math.max(0, Math.floor((gridHeight - charHeight) / 2));
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i].toUpperCase();
                const charData = pixelFont[char];
                
                if (charData) {
                    const charX = startX + i * (charWidth + charSpacing);
                    
                    for (let y = 0; y < charHeight; y++) {
                        for (let x = 0; x < charWidth; x++) {
                            const pixelX = charX + x;
                            const pixelY = startY + y;
                            
                            if (pixelX < gridWidth && pixelY < gridHeight && pixelX >= 0 && pixelY >= 0) {
                                pixelGrid[pixelY][pixelX] = charData[y][x];
                            }
                        }
                    }
                }
            }
        }
        
        function generateHeartPattern() {
            const { gridWidth, gridHeight } = initDisplay();
            const centerX = gridWidth / 2;
            const centerY = gridHeight / 2;
            
            const heart = [
                [0,1,1,0,0,0,1,1,0],
                [1,1,1,1,0,1,1,1,1],
                [1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1],
                [0,1,1,1,1,1,1,1,0],
                [0,0,1,1,1,1,1,0,0],
                [0,0,0,1,1,1,0,0,0],
                [0,0,0,0,1,0,0,0,0]
            ];
            
            const startX = Math.floor(centerX - heart[0].length / 2);
            const startY = Math.floor(centerY - heart.length / 2);
            
            for (let y = 0; y < heart.length; y++) {
                for (let x = 0; x < heart[y].length; x++) {
                    const pixelX = startX + x;
                    const pixelY = startY + y;
                    if (pixelX >= 0 && pixelX < gridWidth && pixelY >= 0 && pixelY < gridHeight) {
                        pixelGrid[pixelY][pixelX] = heart[y][x];
                    }
                }
            }
        }
        
        function generateDotsPattern() {
            const { gridWidth, gridHeight } = initDisplay();
            
            // Clear the grid first
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    pixelGrid[y][x] = 0;
                }
            }
            
            // Adjust for larger dots - each "dot" will be 4x4 pixels (400% larger)
            // So we need to work with a smaller logical grid
            const dotSize = 4;
            const logicalWidth = Math.floor(gridWidth / dotSize);
            const logicalHeight = Math.floor(gridHeight / dotSize);
            
            // Create a logical grid for dot placement
            let logicalGrid = [];
            for (let y = 0; y < logicalHeight; y++) {
                logicalGrid[y] = [];
                for (let x = 0; x < logicalWidth; x++) {
                    logicalGrid[y][x] = 0;
                }
            }
            
            // Increased density by 30% - was 35%, now 45.5%
            const blockSizeX = 2; // Smaller blocks since we're working in logical space
            const blockSizeY = 2;
            
            for (let blockY = 0; blockY < Math.floor(logicalHeight / blockSizeY); blockY++) {
                for (let blockX = 0; blockX < Math.floor(logicalWidth / blockSizeX); blockX++) {
                    
                    // 45.5% chance this block will have dots
                    if (Math.random() < 0.455) {
                        const startX = blockX * blockSizeX;
                        const startY = blockY * blockSizeY;
                        
                        const clusterType = Math.floor(Math.random() * 6);
                        
                        switch(clusterType) {
                            case 0: // Small 2x2 square
                                if (startX + 1 < logicalWidth && startY + 1 < logicalHeight) {
                                    logicalGrid[startY][startX] = 1.0;
                                    logicalGrid[startY][startX + 1] = 1.0;
                                    logicalGrid[startY + 1][startX] = 1.0;
                                    logicalGrid[startY + 1][startX + 1] = 1.0;
                                }
                                break;
                                
                            case 1: // Horizontal line of 2-3 dots (scaled down)
                                const lineLength = 2 + Math.floor(Math.random() * 2);
                                const lineY = startY;
                                for (let i = 0; i < lineLength && startX + i < logicalWidth; i++) {
                                    if (lineY < logicalHeight) {
                                        logicalGrid[lineY][startX + i] = 1.0;
                                    }
                                }
                                break;
                                
                            case 2: // Vertical line of 2 dots
                                const vLineLength = 2;
                                const lineX = startX;
                                for (let i = 0; i < vLineLength && startY + i < logicalHeight; i++) {
                                    if (lineX < logicalWidth) {
                                        logicalGrid[startY + i][lineX] = 1.0;
                                    }
                                }
                                break;
                                
                            case 3: // L-shape
                                if (startX + 1 < logicalWidth && startY + 1 < logicalHeight) {
                                    logicalGrid[startY][startX] = 1.0;
                                    logicalGrid[startY + 1][startX] = 1.0;
                                    logicalGrid[startY + 1][startX + 1] = 1.0;
                                }
                                break;
                                
                            case 4: // Scattered 2-3 individual dots
                                const dotCount = 2 + Math.floor(Math.random() * 2);
                                for (let i = 0; i < dotCount; i++) {
                                    const dotX = startX + Math.floor(Math.random() * blockSizeX);
                                    const dotY = startY + Math.floor(Math.random() * blockSizeY);
                                    if (dotX < logicalWidth && dotY < logicalHeight) {
                                        logicalGrid[dotY][dotX] = 1.0;
                                    }
                                }
                                break;
                                
                            case 5: // 2x1 rectangular cluster
                                if (startX + 1 < logicalWidth) {
                                    logicalGrid[startY][startX] = 1.0;
                                    logicalGrid[startY][startX + 1] = 1.0;
                                }
                                break;
                        }
                    }
                }
            }
            
            // Add some random single dots
            const randomDots = Math.floor(logicalWidth * logicalHeight * 0.026);
            for (let i = 0; i < randomDots; i++) {
                const x = Math.floor(Math.random() * logicalWidth);
                const y = Math.floor(Math.random() * logicalHeight);
                if (logicalGrid[y][x] === 0 && Math.random() > 0.7) {
                    logicalGrid[y][x] = 1.0;
                }
            }
            
            // Convert logical grid to actual pixel grid (4x4 blocks)
            for (let ly = 0; ly < logicalHeight; ly++) {
                for (let lx = 0; lx < logicalWidth; lx++) {
                    if (logicalGrid[ly][lx] > 0) {
                        // Draw a 4x4 block for each logical dot
                        for (let dy = 0; dy < dotSize; dy++) {
                            for (let dx = 0; dx < dotSize; dx++) {
                                const actualX = lx * dotSize + dx;
                                const actualY = ly * dotSize + dy;
                                if (actualX < gridWidth && actualY < gridHeight) {
                                    pixelGrid[actualY][actualX] = 1.0;
                                }
                            }
                        }
                    }
                }
            }
            
            // Store speed categories for each logical dot for animation
            if (!window.dotSpeeds) {
                window.dotSpeeds = [];
                for (let y = 0; y < gridHeight; y++) {
                    window.dotSpeeds[y] = [];
                    for (let x = 0; x < gridWidth; x++) {
                        // Assign speed based on logical dot position
                        const logicalX = Math.floor(x / dotSize);
                        const logicalY = Math.floor(y / dotSize);
                        
                        if (logicalX < logicalWidth && logicalY < logicalHeight && logicalGrid[logicalY][logicalX] > 0) {
                            // Only assign speed to the top-left pixel of each 4x4 block
                            if (x % dotSize === 0 && y % dotSize === 0) {
                                const rand = Math.random();
                                if (rand < 0.15) {
                                    window.dotSpeeds[y][x] = 'slow';
                                } else if (rand < 0.50) {
                                    window.dotSpeeds[y][x] = 'medium';
                                } else if (rand < 0.75) {
                                    window.dotSpeeds[y][x] = 'fast';
                                } else {
                                    window.dotSpeeds[y][x] = 'very_fast';
                                }
                            } else {
                                window.dotSpeeds[y][x] = null; // Non-control pixels
                            }
                        } else {
                            window.dotSpeeds[y][x] = null;
                        }
                    }
                }
            }
        }
        
        function generatePattern() {
            const pattern = document.getElementById('pattern').value;
            const text = document.getElementById('customText').value || 'IONIQ 6 N';
            
            // Clear dot speeds when generating new pattern
            if (pattern === 'dots') {
                window.dotSpeeds = null;
            }
            
            switch(pattern) {
                case 'text':
                    generateTextPattern(text);
                    break;
                case 'heart':
                    generateHeartPattern();
                    break;
                case 'dots':
                    generateDotsPattern();
                    break;
                default:
                    generateTextPattern(text);
            }
            
            drawPixelGrid();
            updateStatus(`Generated ${pattern} pattern!`);
        }
        
        function drawGradientSphere(centerX, centerY, radius, colorType, gridWidth, gridHeight, pulseIntensity = 1.0, sparkles = false) {
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < radius) {
                        const z = Math.sqrt(Math.max(0, radius * radius - dx * dx - dy * dy));
                        const normal = {
                            x: dx / radius,
                            y: dy / radius,
                            z: z / radius
                        };
                        
                        // Enhanced lighting with multiple light sources
                        const light1 = { x: 0.5, y: -0.5, z: 0.7 };
                        const light2 = { x: -0.3, y: 0.3, z: 0.5 };
                        const light3 = { x: 0.0, y: 0.0, z: 1.0 };
                        
                        const dot1 = normal.x * light1.x + normal.y * light1.y + normal.z * light1.z;
                        const dot2 = normal.x * light2.x + normal.y * light2.y + normal.z * light2.z;
                        const dot3 = normal.x * light3.x + normal.y * light3.y + normal.z * light3.z;
                        
                        let intensity = Math.max(0, dot1) * 0.6 + Math.max(0, dot2) * 0.3 + Math.max(0, dot3) * 0.2 + 0.15;
                        intensity *= pulseIntensity;
                        
                        // Add rim lighting effect
                        const rimIntensity = Math.pow(1 - Math.abs(dot3), 2) * 0.4;
                        intensity += rimIntensity * pulseIntensity;
                        
                        // Add sparkle effects if enabled
                        if (sparkles && Math.random() < 0.02) {
                            intensity = Math.min(1.5, intensity + Math.random() * 0.8);
                        }
                        
                        let pixelValue;
                        
                        if (colorType === 'red') {
                            const redLevels = colorThemes.red.levels;
                            const levelIndex = Math.floor(intensity * (redLevels.length - 1));
                            const color = redLevels[Math.min(levelIndex, redLevels.length - 1)];
                            
                            pixelValue = {
                                isSpecialColor: true,
                                color: color,
                                intensity: intensity
                            };
                        } else if (colorType === 'blue') {
                            const blueLevels = colorThemes.blue.levels;
                            const levelIndex = Math.floor(intensity * (blueLevels.length - 1));
                            const color = blueLevels[Math.min(levelIndex, blueLevels.length - 1)];
                            
                            pixelValue = {
                                isSpecialColor: true,
                                color: color,
                                intensity: intensity
                            };
                        } else if (colorType === 'fusion') {
                            const whiteLevels = colorThemes.white.levels;
                            const levelIndex = Math.floor((intensity * 1.4) * (whiteLevels.length - 1));
                            const color = whiteLevels[Math.min(levelIndex, whiteLevels.length - 1)];
                            
                            pixelValue = {
                                isSpecialColor: true,
                                color: color,
                                intensity: intensity * 1.4
                            };
                        }
                        
                        if (!pixelGrid[y][x] || (pixelGrid[y][x].intensity || 0) < intensity) {
                            pixelGrid[y][x] = pixelValue;
                        }
                    }
                }
            }
        }
        
        function drawEclipseRing(centerX, centerY, radius, progress, gridWidth, gridHeight) {
            const ringThickness = 4;
            const intensity = 0.9 + Math.sin(progress * Math.PI * 12) * 0.3;
            
            // Multiple ring layers for depth
            for (let layer = 0; layer < 3; layer++) {
                const layerRadius = radius + layer * 2;
                const layerThickness = ringThickness - layer;
                const layerIntensity = intensity * (1 - layer * 0.2);
                
                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        const dx = x - centerX;
                        const dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (Math.abs(dist - layerRadius) < layerThickness) {
                            const ringIntensity = layerIntensity * (1 - Math.abs(dist - layerRadius) / layerThickness);
                            
                            // Add pulsing energy pattern
                            const angle = Math.atan2(dy, dx);
                            const energyPulse = Math.sin(angle * 8 + progress * Math.PI * 8) * 0.3 + 0.7;
                            const finalIntensity = ringIntensity * energyPulse;
                            
                            const whiteLevels = colorThemes.white.levels;
                            const levelIndex = Math.floor(finalIntensity * (whiteLevels.length - 1));
                            const color = whiteLevels[Math.min(levelIndex, whiteLevels.length - 1)];
                            
                            const pixelValue = {
                                isSpecialColor: true,
                                color: color,
                                intensity: finalIntensity
                            };
                            
                            if (!pixelGrid[y][x] || (pixelGrid[y][x].intensity || 0) < finalIntensity) {
                                pixelGrid[y][x] = pixelValue;
                            }
                        }
                    }
                }
            }
        }
        
        function drawExplosion(centerX, centerY, radius, progress, flashIntensity, gridWidth, gridHeight) {
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < radius) {
                        const angle = Math.atan2(dy, dx);
                        
                        // Multiple burst patterns for complexity
                        const burstPattern1 = Math.sin(angle * 12) * 0.4 + 0.6;
                        const burstPattern2 = Math.sin(angle * 6 + Math.PI/3) * 0.3 + 0.7;
                        const burstPattern3 = Math.sin(angle * 18) * 0.2 + 0.8;
                        const combinedBurst = burstPattern1 * burstPattern2 * burstPattern3;
                        
                        const distanceFactor = 1 - (dist / radius);
                        let intensity = distanceFactor * combinedBurst * (0.7 + flashIntensity * 0.6);
                        
                        // Add explosive shockwave rings
                        const ringDistance = (dist / radius) * 8;
                        const ringEffect = Math.sin(ringDistance - progress * 15) * 0.3 + 0.7;
                        intensity *= ringEffect;
                        
                        const whiteLevels = colorThemes.white.levels;
                        let levelIndex = Math.floor(intensity * (whiteLevels.length - 1));
                        let color = whiteLevels[Math.min(levelIndex, whiteLevels.length - 1)];
                        
                        const pixelValue = {
                            isSpecialColor: true,
                            color: color,
                            intensity: intensity
                        };
                        
                        // Enhanced sparkle effects
                        if (Math.random() < 0.15) {
                            const sparkleIntensity = Math.min(1.8, intensity + Math.random() * 1.2);
                            const sparkIndex = Math.floor(sparkleIntensity * (whiteLevels.length - 1));
                            pixelValue.color = whiteLevels[Math.min(sparkIndex, whiteLevels.length - 1)];
                            pixelValue.intensity = sparkleIntensity;
                        }
                        
                        // Add debris particles
                        if (Math.random() < 0.08 && dist > radius * 0.3) {
                            const debrisIntensity = Math.random() * 0.8 + 0.4;
                            pixelValue.intensity = Math.max(pixelValue.intensity, debrisIntensity);
                        }
                        
                        if (!pixelGrid[y][x] || (pixelGrid[y][x].intensity || 0) < pixelValue.intensity) {
                            pixelGrid[y][x] = pixelValue;
                        }
                    }
                }
            }
        }
        
        function drawEnergyWaves(centerX, centerY, radius, intensity, gridWidth, gridHeight) {
            const waveCount = 5;
            
            for (let wave = 0; wave < waveCount; wave++) {
                const waveRadius = radius - (wave * 6);
                const waveThickness = 3;
                const waveIntensity = intensity * (1 - wave * 0.15);
                
                if (waveRadius > 0) {
                    for (let y = 0; y < gridHeight; y++) {
                        for (let x = 0; x < gridWidth; x++) {
                            const dx = x - centerX;
                            const dy = y - centerY;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (Math.abs(dist - waveRadius) < waveThickness) {
                                const currentWaveIntensity = waveIntensity * (1 - Math.abs(dist - waveRadius) / waveThickness);
                                
                                // Add wave interference patterns
                                const angle = Math.atan2(dy, dx);
                                const interference = Math.sin(angle * 6 + wave * 2) * 0.4 + 0.8;
                                const finalIntensity = currentWaveIntensity * interference;
                                
                                const whiteLevels = colorThemes.white.levels;
                                const levelIndex = Math.floor(finalIntensity * (whiteLevels.length - 1));
                                const color = whiteLevels[Math.min(levelIndex, whiteLevels.length - 1)];
                                
                                const pixelValue = {
                                    isSpecialColor: true,
                                    color: color,
                                    intensity: finalIntensity
                                };
                                
                                if (!pixelGrid[y][x] || (pixelGrid[y][x].intensity || 0) < finalIntensity) {
                                    pixelGrid[y][x] = pixelValue;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        function animateDisplay() {
            const animation = document.getElementById('animation').value;
            const duration = parseInt(document.getElementById('duration').value) * 1000;
            
            if (animation === 'none') {
                updateStatus('No animation selected');
                return;
            }
            
            if (isAnimating) {
                cancelAnimationFrame(animationFrame);
                isAnimating = false;
                if (window.matrixColumns) delete window.matrixColumns;
                if (window.equalizerBars) delete window.equalizerBars;
            }
            
            // Initialize countdown timer if needed
            if (animation === 'countdown') {
                const countdownInput = document.getElementById('countdownTime').value;
                const totalSeconds = parseTimeInput(countdownInput);
                countdownDuration = totalSeconds;
                countdownStartTime = Date.now();
            }
            
            isAnimating = true;
            
            document.getElementById('animateBtn').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'inline-block';
            
            const startTime = Date.now();
            const originalGrid = pixelGrid.map(row => [...row]);
            
            updateStatus(`Animating: ${animation} for ${duration/1000}s`);
            
            function animate() {
                if (!isAnimating || Date.now() - startTime > duration) {
                    isAnimating = false;
                    if (window.matrixColumns) delete window.matrixColumns;
                    if (window.equalizerBars) delete window.equalizerBars;
                    
                    document.getElementById('animateBtn').style.display = 'inline-block';
                    document.getElementById('pauseBtn').style.display = 'none';
                    
                    pixelGrid = originalGrid;
                    drawPixelGrid();
                    updateStatus('Animation complete');
                    return;
                }
                
                const elapsed = Date.now() - startTime;
                const { gridWidth, gridHeight } = { gridWidth: pixelGrid[0].length, gridHeight: pixelGrid.length };
                
                switch(animation) {
                    case 'countdown':
                        if (countdownStartTime) {
                            const elapsedSeconds = Math.floor((Date.now() - countdownStartTime) / 1000);
                            const remainingSeconds = Math.max(0, countdownDuration - elapsedSeconds);
                            const timeString = formatTime(remainingSeconds);
                            generateTextPattern(timeString);
                        }
                        break;
                        
                    case 'dots_flicker':
                        // Dedicated dots flicker animation for 4x4 blocks
                        const dotSize = 4;
                        
                        // Make sure we have dot speeds initialized
                        if (!window.dotSpeeds) {
                            // Initialize dot speeds for existing dots
                            const { gridWidth, gridHeight } = { gridWidth: pixelGrid[0].length, gridHeight: pixelGrid.length };
                            window.dotSpeeds = [];
                            for (let y = 0; y < gridHeight; y++) {
                                window.dotSpeeds[y] = [];
                                for (let x = 0; x < gridWidth; x++) {
                                    // Only assign speeds to control pixels (top-left of each 4x4 block)
                                    if (originalGrid[y][x] > 0 && x % dotSize === 0 && y % dotSize === 0) {
                                        const rand = Math.random();
                                        if (rand < 0.15) {
                                            window.dotSpeeds[y][x] = 'slow';
                                        } else if (rand < 0.50) {
                                            window.dotSpeeds[y][x] = 'medium';
                                        } else if (rand < 0.75) {
                                            window.dotSpeeds[y][x] = 'fast';
                                        } else {
                                            window.dotSpeeds[y][x] = 'very_fast';
                                        }
                                    } else {
                                        window.dotSpeeds[y][x] = null;
                                    }
                                }
                            }
                        }
                        
                        // Variable speed flickering animation for 4x4 blocks
                        for (let y = 0; y < pixelGrid.length; y += dotSize) {
                            for (let x = 0; x < pixelGrid[y].length; x += dotSize) {
                                // Check if this is a control pixel with speed data
                                if (window.dotSpeeds && window.dotSpeeds[y] && window.dotSpeeds[y][x]) {
                                    const speedCategory = window.dotSpeeds[y][x];
                                    let flickerRate = 0;
                                    
                                    // Set flicker rates based on speed category
                                    switch(speedCategory) {
                                        case 'slow':
                                            flickerRate = 0.008; // 0.8% chance per frame
                                            break;
                                        case 'medium':
                                            flickerRate = 0.025; // 2.5% chance per frame
                                            break;
                                        case 'fast':
                                            flickerRate = 0.055; // 5.5% chance per frame
                                            break;
                                        case 'very_fast':
                                            flickerRate = 0.12; // 12% chance per frame
                                            break;
                                    }
                                    
                                    // Apply speed-based flickering to entire 4x4 block
                                    if (Math.random() < flickerRate) {
                                        const currentState = pixelGrid[y][x] > 0;
                                        const newState = currentState ? 0 : 1.0;
                                        
                                        // Toggle entire 4x4 block
                                        for (let dy = 0; dy < dotSize; dy++) {
                                            for (let dx = 0; dx < dotSize; dx++) {
                                                const pixelY = y + dy;
                                                const pixelX = x + dx;
                                                if (pixelY < pixelGrid.length && pixelX < pixelGrid[pixelY].length) {
                                                    // Only toggle if this pixel was part of original pattern
                                                    if (originalGrid[pixelY][pixelX] > 0) {
                                                        pixelGrid[pixelY][pixelX] = newState;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Occasionally add temporary dots
                        if (Math.random() < 0.001) {
                            const randomX = Math.floor(Math.random() * (pixelGrid[0].length / dotSize)) * dotSize;
                            const randomY = Math.floor(Math.random() * (pixelGrid.length / dotSize)) * dotSize;
                            
                            // Add temporary 4x4 dot
                            for (let dy = 0; dy < dotSize; dy++) {
                                for (let dx = 0; dx < dotSize; dx++) {
                                    const pixelY = randomY + dy;
                                    const pixelX = randomX + dx;
                                    if (pixelY < pixelGrid.length && pixelX < pixelGrid[pixelY].length && 
                                        originalGrid[pixelY][pixelX] === 0) {
                                        pixelGrid[pixelY][pixelX] = 1.0;
                                    }
                                }
                            }
                        }
                        
                        // Remove temporary dots
                        for (let y = 0; y < pixelGrid.length; y++) {
                            for (let x = 0; x < pixelGrid[y].length; x++) {
                                if (originalGrid[y][x] === 0 && pixelGrid[y][x] > 0 && Math.random() < 0.02) {
                                    pixelGrid[y][x] = 0;
                                }
                            }
                        }
                        break;
                        
                    case 'pulse':
                        const pulseValue = (Math.sin(elapsed / 200) + 1) / 2;
                        
                        // Regular pulse for all patterns
                        for (let y = 0; y < pixelGrid.length; y++) {
                            for (let x = 0; x < pixelGrid[y].length; x++) {
                                if (originalGrid[y][x] > 0) {
                                    pixelGrid[y][x] = originalGrid[y][x] * (0.3 + pulseValue * 0.7);
                                }
                            }
                        }
                        break;
                        
                    case 'blink':
                        const shouldShow = Math.floor(elapsed / 500) % 2 === 0;
                        
                        // Regular blink for all patterns
                        for (let y = 0; y < pixelGrid.length; y++) {
                            for (let x = 0; x < pixelGrid[y].length; x++) {
                                pixelGrid[y][x] = shouldShow ? originalGrid[y][x] : 0;
                            }
                        }
                        break;
                        
                    case 'glitch':
                        for (let y = 0; y < pixelGrid.length; y++) {
                            for (let x = 0; x < pixelGrid[y].length; x++) {
                                pixelGrid[y][x] = originalGrid[y][x];
                            }
                        }
                        
                        if (Math.floor(elapsed / 150) % 3 !== 0) {
                            for (let y = 0; y < pixelGrid.length; y++) {
                                for (let x = 0; x < pixelGrid[y].length; x++) {
                                    if (originalGrid[y][x] > 0 && Math.random() < 0.15) {
                                        if (Math.random() < 0.5) {
                                            pixelGrid[y][x] = 0;
                                        } else {
                                            pixelGrid[y][x] = Math.random();
                                        }
                                    }
                                    if (originalGrid[y][x] === 0 && Math.random() < 0.05) {
                                        pixelGrid[y][x] = Math.random() * 0.7;
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 'laser':
                        const totalHeight = pixelGrid.length;
                        const scanCycleTime = 2000;
                        const currentTime = elapsed % scanCycleTime;
                        const sweepProgress = currentTime / scanCycleTime;
                        
                        const upwardSweep = sweepProgress * totalHeight;
                        const downwardSweep = totalHeight - (sweepProgress * totalHeight);
                        
                        for (let y = 0; y < pixelGrid.length; y++) {
                            for (let x = 0; x < pixelGrid[y].length; x++) {
                                pixelGrid[y][x] = originalGrid[y][x] * 0.4;
                            }
                        }
                        
                        for (let y = 0; y < pixelGrid.length; y++) {
                            let scanIntensity = 0;
                            
                            const distanceFromUpSweep = Math.abs(y - upwardSweep);
                            if (distanceFromUpSweep < 3) {
                                if (distanceFromUpSweep < 0.5) {
                                    scanIntensity = Math.max(scanIntensity, 1.0);
                                } else if (distanceFromUpSweep < 1.5) {
                                    scanIntensity = Math.max(scanIntensity, 0.8);
                                } else {
                                    scanIntensity = Math.max(scanIntensity, 0.6);
                                }
                            }
                            
                            const distanceFromDownSweep = Math.abs(y - downwardSweep);
                            if (distanceFromDownSweep < 2.5) {
                                if (distanceFromDownSweep < 0.5) {
                                    scanIntensity = Math.max(scanIntensity, 0.9);
                                } else if (distanceFromDownSweep < 1.5) {
                                    scanIntensity = Math.max(scanIntensity, 0.7);
                                }
                            }
                            
                            if (scanIntensity > 0) {
                                for (let x = 0; x < pixelGrid[y].length; x++) {
                                    if (originalGrid[y][x] > 0) {
                                        pixelGrid[y][x] = Math.max(pixelGrid[y][x], originalGrid[y][x] * scanIntensity);
                                    } else {
                                        pixelGrid[y][x] = Math.max(pixelGrid[y][x], scanIntensity * 0.3);
                                    }
                                }
                            }
                        }
                        
                        const whiteLineTime = (elapsed * 1.3) % scanCycleTime;
                        const whiteProgress = whiteLineTime / scanCycleTime;
                        const whiteSweepUp = whiteProgress * totalHeight;
                        const whiteSweepDown = totalHeight - (whiteProgress * totalHeight);
                        
                        const whiteY1 = Math.floor(whiteSweepUp);
                        const whiteY2 = Math.floor(whiteSweepDown);
                        
                        if (whiteY1 >= 0 && whiteY1 < pixelGrid.length) {
                            for (let x = 0; x < pixelGrid[whiteY1].length; x++) {
                                pixelGrid[whiteY1][x] = Math.max(pixelGrid[whiteY1][x], 0.95);
                            }
                        }
                        
                        if (whiteY2 >= 0 && whiteY2 < pixelGrid.length) {
                            for (let x = 0; x < pixelGrid[whiteY2].length; x++) {
                                pixelGrid[whiteY2][x] = Math.max(pixelGrid[whiteY2][x], 0.9);
                            }
                        }
                        break;
                        
                    case 'heartbeat':
                        for (let y = 0; y < gridHeight; y++) {
                            for (let x = 0; x < gridWidth; x++) {
                                pixelGrid[y][x] = 0;
                            }
                        }
                        
                        const beatTime = (elapsed / 1000) * 1.2;
                        const beatCycle = beatTime % 1;
                        
                        let heartScale = 1.0;
                        let intensity = 0.8;
                        
                        if (beatCycle < 0.15) {
                            const lubProgress = beatCycle / 0.15;
                            heartScale = 1.0 + Math.sin(lubProgress * Math.PI) * 0.8;
                            intensity = 0.8 + Math.sin(lubProgress * Math.PI) * 0.6;
                        } else if (beatCycle < 0.35) {
                            heartScale = 1.0;
                            intensity = 0.8;
                        } else if (beatCycle < 0.45) {
                            const dubProgress = (beatCycle - 0.35) / 0.1;
                            heartScale = 1.0 + Math.sin(dubProgress * Math.PI) * 0.5;
                            intensity = 0.8 + Math.sin(dubProgress * Math.PI) * 0.5;
                        } else {
                            heartScale = 1.0;
                            intensity = 0.8;
                        }
                        
                        const animatedHeart = [
                            [0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,0,0,0],
                            [0,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0,0],
                            [0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0],
                            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                            [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                            [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                            [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                            [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                            [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0],
                            [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0]
                        ];
                        
                        const heartCenterX = gridWidth / 2;
                        const heartCenterY = gridHeight / 2;
                        const scaledHeartWidth = Math.floor(animatedHeart[0].length * heartScale);
                        const scaledHeartHeight = Math.floor(animatedHeart.length * heartScale);
                        const startX = Math.floor(heartCenterX - scaledHeartWidth / 2);
                        const startY = Math.floor(heartCenterY - scaledHeartHeight / 2);
                        
                        for (let y = 0; y < scaledHeartHeight; y++) {
                            for (let x = 0; x < scaledHeartWidth; x++) {
                                const sourceY = Math.floor(y / heartScale);
                                const sourceX = Math.floor(x / heartScale);
                                
                                if (sourceY < animatedHeart.length && sourceX < animatedHeart[0].length && 
                                    animatedHeart[sourceY][sourceX] === 1) {
                                    
                                    const pixelX = startX + x;
                                    const pixelY = startY + y;
                                    
                                    if (pixelX >= 0 && pixelX < gridWidth && pixelY >= 0 && pixelY < gridHeight) {
                                        pixelGrid[pixelY][pixelX] = intensity;
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 'collision':
                        const centerX = gridWidth / 2;
                        const centerY = gridHeight / 2;
                        const sphereRadius = Math.min(gridWidth, gridHeight) * 0.15;
                        
                        const totalDuration = duration;
                        const approachTime = totalDuration * 0.35;
                        const eclipseTime = totalDuration * 0.15;
                        const explosionTime = totalDuration * 0.25;
                        const fusionTime = totalDuration * 0.25;
                        
                        let phase = 'approach';
                        let phaseProgress = 0;
                        
                        if (elapsed < approachTime) {
                            phase = 'approach';
                            phaseProgress = elapsed / approachTime;
                        } else if (elapsed < approachTime + eclipseTime) {
                            phase = 'eclipse';
                            phaseProgress = (elapsed - approachTime) / eclipseTime;
                        } else if (elapsed < approachTime + eclipseTime + explosionTime) {
                            phase = 'explosion';
                            phaseProgress = (elapsed - approachTime - eclipseTime) / explosionTime;
                        } else {
                            phase = 'fusion';
                            phaseProgress = (elapsed - approachTime - eclipseTime - explosionTime) / fusionTime;
                        }
                        
                        for (let y = 0; y < gridHeight; y++) {
                            for (let x = 0; x < gridWidth; x++) {
                                pixelGrid[y][x] = 0;
                            }
                        }
                        
                        if (phase === 'approach') {
                            const startDistance = gridWidth * 0.45;
                            const currentDistance = startDistance * (1 - Math.pow(phaseProgress, 0.8));
                            
                            const leftSphereX = centerX - currentDistance;
                            const rightSphereX = centerX + currentDistance;
                            
                            // Add acceleration effects as spheres get closer
                            const speedIntensity = 1 + phaseProgress * 1.5;
                            const trailLength = Math.floor(phaseProgress * 8);
                            
                            // Draw motion trails
                            for (let trail = 0; trail < trailLength; trail++) {
                                const trailDistance = currentDistance + trail * 4;
                                const trailAlpha = (1 - trail / trailLength) * 0.6;
                                const leftTrailX = centerX - trailDistance;
                                const rightTrailX = centerX + trailDistance;
                                
                                if (leftTrailX > 0) {
                                    drawGradientSphere(leftTrailX, centerY, sphereRadius * 0.8, 'red', gridWidth, gridHeight, trailAlpha, false);
                                }
                                if (rightTrailX < gridWidth) {
                                    drawGradientSphere(rightTrailX, centerY, sphereRadius * 0.8, 'blue', gridWidth, gridHeight, trailAlpha, false);
                                }
                            }
                            
                            drawGradientSphere(leftSphereX, centerY, sphereRadius, 'red', gridWidth, gridHeight, speedIntensity, true);
                            drawGradientSphere(rightSphereX, centerY, sphereRadius, 'blue', gridWidth, gridHeight, speedIntensity, true);
                            
                        } else if (phase === 'eclipse') {
                            const overlap = Math.pow(phaseProgress, 0.7) * sphereRadius * 0.9;
                            const leftSphereX = centerX - overlap;
                            const rightSphereX = centerX + overlap;
                            
                            // Intense energy buildup
                            const energyIntensity = 1 + phaseProgress * 2;
                            
                            drawGradientSphere(leftSphereX, centerY, sphereRadius, 'red', gridWidth, gridHeight, energyIntensity, true);
                            drawGradientSphere(rightSphereX, centerY, sphereRadius, 'blue', gridWidth, gridHeight, energyIntensity, true);
                            
                            // Multiple pulsing energy rings
                            for (let ring = 0; ring < 3; ring++) {
                                const ringRadius = sphereRadius * (1.3 + phaseProgress * 0.8 + ring * 0.3);
                                const ringProgress = phaseProgress + ring * 0.2;
                                drawEclipseRing(centerX, centerY, ringRadius, ringProgress, gridWidth, gridHeight);
                            }
                            
                            // Add electrical arcs between spheres
                            if (phaseProgress > 0.3) {
                                for (let arc = 0; arc < 5; arc++) {
                                    const arcY = centerY + (Math.random() - 0.5) * sphereRadius;
                                    const arcStartX = leftSphereX + sphereRadius * 0.8;
                                    const arcEndX = rightSphereX - sphereRadius * 0.8;
                                    
                                    for (let x = arcStartX; x <= arcEndX; x += 2) {
                                        const arcIntensity = Math.random() * 0.8 + 0.4;
                                        const arcPixelY = Math.floor(arcY + Math.sin(x * 0.3) * 3);
                                        
                                        if (arcPixelY >= 0 && arcPixelY < gridHeight && x >= 0 && x < gridWidth) {
                                            const whiteLevels = colorThemes.white.levels;
                                            const levelIndex = Math.floor(arcIntensity * (whiteLevels.length - 1));
                                            const color = whiteLevels[Math.min(levelIndex, whiteLevels.length - 1)];
                                            
                                            if (Math.random() < 0.7) {
                                                pixelGrid[arcPixelY][Math.floor(x)] = {
                                                    isSpecialColor: true,
                                                    color: color,
                                                    intensity: arcIntensity
                                                };
                                            }
                                        }
                                    }
                                }
                            }
                            
                        } else if (phase === 'explosion') {
                            const explosionRadius = sphereRadius * (1.2 + phaseProgress * 4);
                            const flashIntensity = Math.sin(phaseProgress * Math.PI * 6) * (1 - phaseProgress * 0.3);
                            
                            drawExplosion(centerX, centerY, explosionRadius, phaseProgress, flashIntensity, gridWidth, gridHeight);
                            
                            // Screen-wide flash effects
                            if (flashIntensity > 0.6) {
                                for (let y = 0; y < gridHeight; y++) {
                                    for (let x = 0; x < gridWidth; x++) {
                                        if (Math.random() < 0.4) {
                                            const flashValue = flashIntensity * (0.5 + Math.random() * 0.5);
                                            pixelGrid[y][x] = Math.max(pixelGrid[y][x] || 0, flashValue);
                                        }
                                    }
                                }
                            }
                            
                            // Flying debris particles
                            for (let debris = 0; debris < 20; debris++) {
                                const debrisAngle = (debris / 20) * Math.PI * 2;
                                const debrisSpeed = phaseProgress * explosionRadius * 1.5;
                                const debrisX = centerX + Math.cos(debrisAngle) * debrisSpeed;
                                const debrisY = centerY + Math.sin(debrisAngle) * debrisSpeed;
                                
                                if (debrisX >= 0 && debrisX < gridWidth && debrisY >= 0 && debrisY < gridHeight) {
                                    const debrisIntensity = (1 - phaseProgress) * (Math.random() * 0.6 + 0.4);
                                    pixelGrid[Math.floor(debrisY)][Math.floor(debrisX)] = Math.max(
                                        pixelGrid[Math.floor(debrisY)][Math.floor(debrisX)] || 0, 
                                        debrisIntensity
                                    );
                                }
                            }
                            
                        } else if (phase === 'fusion') {
                            const fusedRadius = sphereRadius * (1.8 - phaseProgress * 0.5);
                            const waveIntensity = (1 - phaseProgress * 0.7) * 0.8;
                            const coreIntensity = 1.2 + Math.sin(phaseProgress * Math.PI * 4) * 0.4;
                            
                            // Pulsing fusion core
                            drawGradientSphere(centerX, centerY, fusedRadius, 'fusion', gridWidth, gridHeight, coreIntensity, true);
                            
                            // Multiple expanding energy waves
                            for (let wave = 0; wave < 4; wave++) {
                                const waveRadius = fusedRadius + (phaseProgress * sphereRadius * 3) + wave * 12;
                                const wavePhaseIntensity = waveIntensity * (1 - wave * 0.2);
                                drawEnergyWaves(centerX, centerY, waveRadius, wavePhaseIntensity, gridWidth, gridHeight);
                            }
                            
                            // Stabilization particles
                            if (phaseProgress > 0.5) {
                                for (let particle = 0; particle < 30; particle++) {
                                    const particleAngle = (particle / 30) * Math.PI * 2 + phaseProgress * Math.PI;
                                    const particleRadius = fusedRadius * (1.2 + Math.sin(phaseProgress * Math.PI * 3) * 0.3);
                                    const particleX = centerX + Math.cos(particleAngle) * particleRadius;
                                    const particleY = centerY + Math.sin(particleAngle) * particleRadius;
                                    
                                    if (particleX >= 0 && particleX < gridWidth && particleY >= 0 && particleY < gridHeight) {
                                        const particleIntensity = waveIntensity * (Math.random() * 0.4 + 0.6);
                                        const whiteLevels = colorThemes.white.levels;
                                        const levelIndex = Math.floor(particleIntensity * (whiteLevels.length - 1));
                                        const color = whiteLevels[Math.min(levelIndex, whiteLevels.length - 1)];
                                        
                                        pixelGrid[Math.floor(particleY)][Math.floor(particleX)] = {
                                            isSpecialColor: true,
                                            color: color,
                                            intensity: particleIntensity
                                        };
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 'matrix':
                        const customTextForMatrix = document.getElementById('customText').value || 'IONIQ 6 N';
                        const matrixColorScheme = document.getElementById('matrixColor').value;
                        
                        for (let y = 0; y < gridHeight; y++) {
                            for (let x = 0; x < gridWidth; x++) {
                                pixelGrid[y][x] = 0;
                            }
                        }
                        
                        if (!window.matrixColumns || elapsed < 100) {
                            if (window.matrixColumns) delete window.matrixColumns;
                            window.matrixColumns = [];
                            
                            const words = customTextForMatrix.trim().split(/\s+/);
                            const columnCount = 25;
                            const columnWidth = Math.floor(gridWidth / columnCount);
                            
                            for (let i = 0; i < columnCount; i++) {
                                window.matrixColumns.push({
                                    x: i * columnWidth + Math.random() * (columnWidth - 4),
                                    y: Math.random() * -gridHeight,
                                    speed: 0.5 + Math.random() * 1.0,
                                    trail: [],
                                    brightness: 0.8 + Math.random() * 0.2,
                                    words: words,
                                    currentWordIndex: Math.floor(Math.random() * words.length),
                                    currentCharIndex: 0
                                });
                            }
                        }
                        
                        for (let col of window.matrixColumns) {
                            col.y += col.speed;
                            
                            if (col.y > gridHeight + 20) {
                                col.y = Math.random() * -30 - 20;
                                col.speed = 0.5 + Math.random() * 1.0;
                                col.trail = [];
                                col.brightness = 0.8 + Math.random() * 0.2;
                                col.currentWordIndex = Math.floor(Math.random() * col.words.length);
                                col.currentCharIndex = 0;
                            }
                            
                            const currentWord = col.words[col.currentWordIndex];
                            const currentChar = currentWord[col.currentCharIndex];
                            
                            if (Math.random() < 0.1) {
                                col.currentCharIndex++;
                                if (col.currentCharIndex >= currentWord.length) {
                                    col.currentCharIndex = 0;
                                    col.currentWordIndex = (col.currentWordIndex + 1) % col.words.length;
                                }
                            }
                            
                            col.trail.unshift({ y: col.y, char: currentChar });
                            if (col.trail.length > 15) {
                                col.trail.pop();
                            }
                            
                            for (let i = 0; i < col.trail.length; i++) {
                                const trailChar = col.trail[i];
                                const charY = Math.floor(trailChar.y - i * 6);
                                
                                if (charY >= 0 && charY < gridHeight - 5) {
                                    const char = trailChar.char ? trailChar.char.toUpperCase() : ' ';
                                    const charData = smallPixelFont[char];
                                    
                                    if (charData) {
                                        let brightness;
                                        if (i === 0) {
                                            brightness = col.brightness;
                                        } else {
                                            brightness = Math.max(0.1, (1 - i / col.trail.length) * 0.8);
                                        }
                                        
                                        for (let y = 0; y < 5; y++) {
                                            for (let x = 0; x < 3; x++) {
                                                const pixelX = Math.floor(col.x) + x;
                                                const pixelY = charY + y;
                                                
                                                if (pixelX < gridWidth && pixelY < gridHeight && pixelX >= 0 && pixelY >= 0) {
                                                    if (charData[y] && charData[y][x]) {
                                                        let pixelValue;
                                                        
                                                        if (i === 0) {
                                                            const whiteLevels = colorThemes.white.levels;
                                                            const levelIndex = Math.floor(brightness * (whiteLevels.length - 1));
                                                            const color = whiteLevels[Math.min(levelIndex, whiteLevels.length - 1)];
                                                            
                                                            pixelValue = {
                                                                isSpecialColor: true,
                                                                color: color,
                                                                intensity: brightness
                                                            };
                                                        } else {
                                                            const selectedLevels = colorThemes[matrixColorScheme].levels;
                                                            const levelIndex = Math.floor(brightness * (selectedLevels.length - 1));
                                                            const color = selectedLevels[Math.min(levelIndex, selectedLevels.length - 1)];
                                                            
                                                            pixelValue = {
                                                                isSpecialColor: true,
                                                                color: color,
                                                                intensity: brightness
                                                            };
                                                        }
                                                        
                                                        if (!pixelGrid[pixelY][pixelX] || (pixelGrid[pixelY][pixelX].intensity || 0) < brightness) {
                                                            pixelGrid[pixelY][pixelX] = pixelValue;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 'equalizer':
                        for (let y = 0; y < gridHeight; y++) {
                            for (let x = 0; x < gridWidth; x++) {
                                pixelGrid[y][x] = 0;
                            }
                        }
                        
                        if (!window.equalizerBars) {
                            window.equalizerBars = [];
                            const pairCount = 20;
                            const barWidth = 2;
                            const pairSpacing = 4;
                            const totalWidth = pairCount * (barWidth * 2 + pairSpacing) - pairSpacing;
                            const startX = Math.floor((gridWidth - totalWidth) / 2);
                            
                            for (let i = 0; i < pairCount; i++) {
                                const pairX = startX + i * (barWidth * 2 + pairSpacing);
                                const frequency = i / (pairCount - 1);
                                
                                window.equalizerBars.push({
                                    x: pairX,
                                    width: barWidth,
                                    currentHeight: 0,
                                    targetHeight: 0,
                                    peakHeight: 0,
                                    peakDecay: 0,
                                    frequency: frequency,
                                    colorType: 'red',
                                    bassResponse: Math.max(0.3, 1.2 - (frequency * 1.5)),
                                    midResponse: frequency > 0.2 && frequency < 0.7 ? 0.8 : 0.3,
                                    trebleResponse: frequency > 0.6 ? 0.9 : 0.2,
                                    riseSpeed: 0.95,
                                    fallSpeed: 0.75,
                                    sensitivity: 1.4
                                });
                                
                                window.equalizerBars.push({
                                    x: pairX + barWidth,
                                    width: barWidth,
                                    currentHeight: 0,
                                    targetHeight: 0,
                                    peakHeight: 0,
                                    peakDecay: 0,
                                    frequency: frequency,
                                    colorType: 'blue',
                                    bassResponse: frequency < 0.4 ? 0.6 : 0.2,
                                    midResponse: frequency > 0.3 && frequency < 0.8 ? 1.1 : 0.4,
                                    trebleResponse: frequency > 0.5 ? 1.3 : 0.3,
                                    riseSpeed: 0.6,
                                    fallSpeed: 0.9,
                                    sensitivity: 1.0
                                });
                            }
                        }
                        
                        const time = elapsed / 1000;
                        const beatFreq = 2.3;
                        
                        const kickDrum = Math.max(0, Math.sin(time * beatFreq * Math.PI * 2)) * 0.9;
                        const snare = Math.max(0, Math.sin((time - 0.22) * beatFreq * Math.PI * 2)) * 0.7;
                        const hiHat = Math.sin(time * beatFreq * 8 * Math.PI * 2) * 0.4 + 0.4;
                        const bassLine = Math.sin(time * beatFreq * 0.5 * Math.PI * 2) * 0.6 + 0.5;
                        const vocals = Math.sin(time * 0.8 * Math.PI * 2) * 0.5 + 0.5;
                        const synth = Math.sin(time * 1.3 * Math.PI * 2) * 0.4 + 0.3;
                        const cymbal = Math.max(0, Math.sin(time * 0.25 * Math.PI * 2)) * 0.8;
                        
                        const breakdown = Math.sin(time * 0.1 * Math.PI * 2) > 0.8 ? 0.3 : 1.0;
                        const buildup = Math.max(0, Math.sin(time * 0.05 * Math.PI * 2)) * 0.5 + 0.5;
                        
                        for (let bar of window.equalizerBars) {
                            let intensity = 0;
                            const randomFactor = (Math.random() - 0.5) * 0.4;
                            
                            if (bar.frequency <= 0.3) {
                                if (bar.colorType === 'red') {
                                    intensity = (kickDrum * 1.2 + bassLine * 0.8) * bar.bassResponse;
                                    intensity += snare * 0.6;
                                } else {
                                    intensity = bassLine * bar.bassResponse * 0.9;
                                    intensity += kickDrum * 0.4;
                                }
                            } else if (bar.frequency <= 0.6) {
                                if (bar.colorType === 'red') {
                                    intensity = (snare * 1.4 + vocals * 0.6 + synth * 0.8) * bar.midResponse;
                                    intensity += cymbal * 0.9;
                                } else {
                                    intensity = (vocals * 1.1 + synth * 1.2 + bassLine * 0.4) * bar.midResponse;
                                }
                            } else {
                                if (bar.colorType === 'red') {
                                    intensity = (hiHat * 1.3 + cymbal * 1.5 + snare * 0.4) * bar.trebleResponse;
                                    intensity += Math.sin(time * 5.7 * Math.PI * 2) * 0.3;
                                } else {
                                    intensity = (vocals * 0.8 + synth * 0.9 + hiHat * 0.7) * bar.trebleResponse;
                                    intensity += Math.sin(time * 2.1 * Math.PI * 2) * 0.2;
                                }
                            }
                            
                            intensity *= breakdown * buildup;
                            intensity += randomFactor;
                            intensity *= bar.sensitivity;
                            
                            intensity = Math.max(0, Math.min(1.8, intensity));
                            bar.targetHeight = intensity * (gridHeight - 2);
                            
                            if (bar.targetHeight > bar.currentHeight) {
                                bar.currentHeight = bar.currentHeight * (1 - bar.riseSpeed) + bar.targetHeight * bar.riseSpeed;
                            } else {
                                bar.currentHeight = bar.currentHeight * bar.fallSpeed + bar.targetHeight * (1 - bar.fallSpeed);
                            }
                            
                            if (bar.currentHeight > bar.peakHeight) {
                                bar.peakHeight = bar.currentHeight;
                                bar.peakDecay = 0;
                            } else {
                                const decayRate = bar.colorType === 'red' ? 0.025 : 0.015;
                                bar.peakDecay += decayRate;
                                bar.peakHeight = Math.max(bar.currentHeight, bar.peakHeight - bar.peakDecay);
                            }
                        }
                        
                        for (let bar of window.equalizerBars) {
                            const barHeight = Math.floor(bar.currentHeight);
                            const peakY = Math.floor(gridHeight - bar.peakHeight - 1);
                            
                            const colorPalette = bar.colorType === 'blue' ? colorThemes.blue : colorThemes.red;
                            
                            for (let y = 0; y < barHeight; y++) {
                                for (let x = 0; x < bar.width; x++) {
                                    const pixelX = bar.x + x;
                                    const pixelY = gridHeight - 1 - y;
                                    
                                    if (pixelX < gridWidth && pixelY >= 0 && pixelY < gridHeight) {
                                        const heightRatio = y / Math.max(1, barHeight);
                                        let intensity;
                                        
                                        if (heightRatio > 0.8) {
                                            intensity = 0.9 + heightRatio * 0.1;
                                        } else if (heightRatio > 0.6) {
                                            intensity = 0.7 + heightRatio * 0.2;
                                        } else if (heightRatio > 0.3) {
                                            intensity = 0.5 + heightRatio * 0.2;
                                        } else {
                                            intensity = 0.3 + heightRatio * 0.2;
                                        }
                                        
                                        const levelIndex = Math.floor(intensity * (colorPalette.levels.length - 1));
                                        const color = colorPalette.levels[Math.min(levelIndex, colorPalette.levels.length - 1)];
                                        
                                        const pixelValue = {
                                            isSpecialColor: true,
                                            color: color,
                                            intensity: intensity
                                        };
                                        
                                        pixelGrid[pixelY][pixelX] = pixelValue;
                                    }
                                }
                            }
                            
                            if (bar.peakHeight > 2) {
                                for (let x = 0; x < bar.width; x++) {
                                    const pixelX = bar.x + x;
                                    
                                    if (pixelX < gridWidth && peakY >= 0 && peakY < gridHeight) {
                                        const whiteLevels = colorThemes.white.levels;
                                        const peakColor = whiteLevels[whiteLevels.length - 1];
                                        
                                        const peakPixel = {
                                            isSpecialColor: true,
                                            color: peakColor,
                                            intensity: 1.0
                                        };
                                        
                                        pixelGrid[peakY][pixelX] = peakPixel;
                                    }
                                }
                            }
                        }
                        break;
                }
                
                drawPixelGrid();
                animationFrame = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        function pauseAnimation() {
            if (isAnimating) {
                isAnimating = false;
                cancelAnimationFrame(animationFrame);
                
                document.getElementById('animateBtn').style.display = 'inline-block';
                document.getElementById('pauseBtn').style.display = 'none';
                
                updateStatus('Animation paused - current frame preserved');
            }
        }
        
        function saveAsImage() {
            const link = document.createElement('a');
            link.download = `pixel-art-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
            updateStatus('Image saved!');
        }
        
        // Initialize
        initDisplay();
        generatePattern();
        updateStatus('Ready to create retro-future graphics!');
    </script>
</body>
</html>
